diff --git a/builds/any/rootfs/buster/common/amd64-base-packages.yml b/builds/any/rootfs/buster/common/amd64-base-packages.yml
index 19e08067..81be9ada 100644
--- a/builds/any/rootfs/buster/common/amd64-base-packages.yml
+++ b/builds/any/rootfs/buster/common/amd64-base-packages.yml
@@ -12,6 +12,7 @@
 - onl-kernel-4.14-lts-x86-64-all-modules
 - onl-kernel-4.19-lts-x86-64-all-modules
 - onl-kernel-5.4-lts-x86-64-all-modules
+- onl-kernel-6.1-lts-x86-64-all-modules
 - efibootmgr
 - gdisk
 - acpid
diff --git a/builds/any/rootfs/jessie/common/amd64-base-packages.yml b/builds/any/rootfs/jessie/common/amd64-base-packages.yml
index 141e549b..f8b46006 100644
--- a/builds/any/rootfs/jessie/common/amd64-base-packages.yml
+++ b/builds/any/rootfs/jessie/common/amd64-base-packages.yml
@@ -15,5 +15,6 @@
 - onl-kernel-4.14-lts-x86-64-all-modules
 - onl-kernel-4.19-lts-x86-64-all-modules
 - onl-kernel-5.4-lts-x86-64-all-modules
+- onl-kernel-6.1-lts-x86-64-all-modules
 - efibootmgr
 - gdisk
diff --git a/builds/any/rootfs/stretch/common/amd64-base-packages.yml b/builds/any/rootfs/stretch/common/amd64-base-packages.yml
index b6799979..873d091c 100644
--- a/builds/any/rootfs/stretch/common/amd64-base-packages.yml
+++ b/builds/any/rootfs/stretch/common/amd64-base-packages.yml
@@ -13,6 +13,7 @@
 - onl-kernel-4.14-lts-x86-64-all-modules
 - onl-kernel-4.19-lts-x86-64-all-modules
 - onl-kernel-5.4-lts-x86-64-all-modules
+- onl-kernel-6.1-lts-x86-64-all-modules
 - efibootmgr
 - gdisk
 - acpid
diff --git a/packages/base/all/vendor-config-onl/src/lib/platform-config-defaults-x86-64.yml b/packages/base/all/vendor-config-onl/src/lib/platform-config-defaults-x86-64.yml
index bc373187..f221b426 100644
--- a/packages/base/all/vendor-config-onl/src/lib/platform-config-defaults-x86-64.yml
+++ b/packages/base/all/vendor-config-onl/src/lib/platform-config-defaults-x86-64.yml
@@ -44,6 +44,10 @@ default:
       =: kernel-5.4-lts-x86_64-all
       package: onl-kernel-5.4-lts-x86-64-all:amd64
 
+    kernel-6.1: &kernel-6-1
+      =: kernel-6.1-lts-x86_64-all
+      package: onl-kernel-6.1-lts-x86-64-all:amd64
+
     # pick one of the above kernels
     kernel:
       <<: *kernel-3-16
diff --git a/packages/base/amd64/upgrade/PKG.yml b/packages/base/amd64/upgrade/PKG.yml
index 9ec35a98..52da24f7 100644
--- a/packages/base/amd64/upgrade/PKG.yml
+++ b/packages/base/amd64/upgrade/PKG.yml
@@ -5,6 +5,7 @@ prerequisites:
       - onl-kernel-4.14-lts-x86-64-all:amd64
       - onl-kernel-4.19-lts-x86-64-all:amd64
       - onl-kernel-5.4-lts-x86-64-all:amd64
+      - onl-kernel-6.1-lts-x86-64-all:amd64
       - onl-loader-initrd:amd64
     stage: 3
 
diff --git a/packages/base/amd64/upgrade/builds/Makefile b/packages/base/amd64/upgrade/builds/Makefile
index 9b4b381a..680fe0dd 100644
--- a/packages/base/amd64/upgrade/builds/Makefile
+++ b/packages/base/amd64/upgrade/builds/Makefile
@@ -6,6 +6,7 @@ $(eval $(call onlpm_find_file_add,X,onl-kernel-4.9-lts-x86-64-all:amd64,kernel-4
 $(eval $(call onlpm_find_file_add,X,onl-kernel-4.14-lts-x86-64-all:amd64,kernel-4.14-lts-x86_64-all,FILES))
 $(eval $(call onlpm_find_file_add,X,onl-kernel-4.19-lts-x86-64-all:amd64,kernel-4.19-lts-x86_64-all,FILES))
 $(eval $(call onlpm_find_file_add,X,onl-kernel-5.4-lts-x86-64-all:amd64,kernel-5.4-lts-x86_64-all,FILES))
+$(eval $(call onlpm_find_file_add,X,onl-kernel-6.1-lts-x86-64-all:amd64,kernel-6.1-lts-x86_64-all,FILES))
 
 # Loader initrd and manifest -> $FILES
 $(eval $(call onlpm_find_file_add,X,onl-loader-initrd:amd64,onl-loader-initrd-amd64.cpio.gz,FILES))
diff --git a/packages/base/any/kernels/modules/accton_i2c_psu.c b/packages/base/any/kernels/modules/accton_i2c_psu.c
index 279ffd9d..d0a9eaad 100755
--- a/packages/base/any/kernels/modules/accton_i2c_psu.c
+++ b/packages/base/any/kernels/modules/accton_i2c_psu.c
@@ -357,7 +357,11 @@ exit:
     return status;
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6,1,0)
 static int accton_i2c_psu_remove(struct i2c_client *client)
+#else
+static void accton_i2c_psu_remove(struct i2c_client *client)
+#endif
 {
     struct accton_i2c_psu_data *data = i2c_get_clientdata(client);
 
@@ -365,7 +369,10 @@ static int accton_i2c_psu_remove(struct i2c_client *client)
     sysfs_remove_group(&client->dev.kobj, &accton_i2c_psu_group);
     kfree(data);
     
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6,1,0)
     return 0;
+#endif
+
 }
 /* Support psu moduel
  */
diff --git a/packages/base/any/kernels/modules/cpr_4011_4mxx.c b/packages/base/any/kernels/modules/cpr_4011_4mxx.c
index cfb58ee4..27e5ab79 100644
--- a/packages/base/any/kernels/modules/cpr_4011_4mxx.c
+++ b/packages/base/any/kernels/modules/cpr_4011_4mxx.c
@@ -270,7 +270,11 @@ exit:
     return status;
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6,1,0)
 static int cpr_4011_4mxx_remove(struct i2c_client *client)
+#else
+static void cpr_4011_4mxx_remove(struct i2c_client *client)
+#endif
 {
     struct cpr_4011_4mxx_data *data = i2c_get_clientdata(client);
 
@@ -278,7 +282,9 @@ static int cpr_4011_4mxx_remove(struct i2c_client *client)
     sysfs_remove_group(&client->dev.kobj, &cpr_4011_4mxx_group);
     kfree(data);
     
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6,1,0)
     return 0;
+#endif
 }
 
 static const struct i2c_device_id cpr_4011_4mxx_id[] = {
diff --git a/packages/base/any/kernels/modules/dps850.c b/packages/base/any/kernels/modules/dps850.c
index cb7c1d8f..0a00600c 100755
--- a/packages/base/any/kernels/modules/dps850.c
+++ b/packages/base/any/kernels/modules/dps850.c
@@ -280,7 +280,11 @@ exit:
 	return status;
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6,1,0)
 static int dps850_remove(struct i2c_client *client)
+#else
+static void dps850_remove(struct i2c_client *client)
+#endif
 {
 	struct dps850_data *data = i2c_get_clientdata(client);
 
@@ -288,7 +292,9 @@ static int dps850_remove(struct i2c_client *client)
 	sysfs_remove_group(&client->dev.kobj, &dps850_group);
 	kfree(data);
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6,1,0)
 	return 0;
+#endif
 }
 
 static const struct i2c_device_id dps850_id[] = {
diff --git a/packages/base/any/kernels/modules/emerson700.c b/packages/base/any/kernels/modules/emerson700.c
index b1a537c8..807b0ad6 100644
--- a/packages/base/any/kernels/modules/emerson700.c
+++ b/packages/base/any/kernels/modules/emerson700.c
@@ -237,4 +237,8 @@ MODULE_AUTHOR("Audi Hsu	");
 MODULE_DESCRIPTION("Emerson 700 PMBus driver");
 MODULE_LICENSE("GPL");
 
+#else
+
+MODULE_LICENSE("GPL");
+
 #endif /* #if LINUX_VERSION_CODE < KERNEL_VERSION(5,4,0) */
diff --git a/packages/base/any/kernels/modules/optoe.c b/packages/base/any/kernels/modules/optoe.c
index 6354674a..36d5229c 100644
--- a/packages/base/any/kernels/modules/optoe.c
+++ b/packages/base/any/kernels/modules/optoe.c
@@ -125,6 +125,7 @@
 #include <linux/sysfs.h>
 #include <linux/jiffies.h>
 #include <linux/i2c.h>
+#include <linux/version.h>
 
 #ifdef EEPROM_CLASS
 #include <linux/eeprom_class.h>
@@ -801,7 +802,11 @@ static ssize_t optoe_bin_write(struct file *filp, struct kobject *kobj,
 	return optoe_read_write(optoe, buf, off, count, OPTOE_WRITE_OP);
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6,1,0)
 static int optoe_remove(struct i2c_client *client)
+#else
+static void optoe_remove(struct i2c_client *client)
+#endif
 {
 	struct optoe_data *optoe;
 	int i;
@@ -819,7 +824,10 @@ static int optoe_remove(struct i2c_client *client)
 
 	kfree(optoe->writebuf);
 	kfree(optoe);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6,1,0)
 	return 0;
+#endif
 }
 
 static ssize_t show_dev_class(struct device *dev,
@@ -860,8 +868,13 @@ static ssize_t set_dev_class(struct device *dev,
 		/* SFP family */
 		/* if it doesn't exist, create 0x51 i2c address */
 		if (!optoe->client[1]) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,5,0)
 			optoe->client[1] = i2c_new_dummy(client->adapter, 0x51);
 			if (!optoe->client[1]) {
+#else
+			optoe->client[1] = i2c_new_dummy_device(client->adapter, 0x51);
+			if (IS_ERR(optoe->client[1])) {
+#endif
 				dev_err(&client->dev,
 					"address 0x51 unavailable\n");
 				mutex_unlock(&optoe->lock);
@@ -1095,8 +1108,13 @@ static int optoe_probe(struct i2c_client *client,
 
 	/* SFF-8472 spec requires that the second I2C address be 0x51 */
 	if (num_addresses == 2) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,5,0)
 		optoe->client[1] = i2c_new_dummy(client->adapter, 0x51);
 		if (!optoe->client[1]) {
+#else
+		optoe->client[1] = i2c_new_dummy_device(client->adapter, 0x51);
+		if (IS_ERR(optoe->client[1])) {
+#endif
 			dev_err(&client->dev, "address 0x51 unavailable\n");
 			err = -EADDRINUSE;
 			goto err_struct;
diff --git a/packages/base/any/kernels/modules/ym2651y.c b/packages/base/any/kernels/modules/ym2651y.c
index d85e8454..d7809997 100755
--- a/packages/base/any/kernels/modules/ym2651y.c
+++ b/packages/base/any/kernels/modules/ym2651y.c
@@ -530,6 +530,38 @@ static const struct attribute_group ym2651y_group = {
     .attrs = ym2651y_attributes,
 };
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,9,0)
+static umode_t ym2651y_is_visible(const void *drvdata,
+                  enum hwmon_sensor_types type,
+                  u32 attr, int channel)
+{
+    return 0;
+}
+
+static u32 ym2651y_hwmon_config[] = {
+    HWMON_P_LABEL,
+};
+
+static const struct hwmon_channel_info ym2651y_hwmon_channel_info = {
+    .type = hwmon_power,
+    .config = ym2651y_hwmon_config,
+};
+
+static const struct hwmon_channel_info *ym2651y_hwmon_info[] = {
+    &ym2651y_hwmon_channel_info,
+    NULL,
+};
+
+static const struct hwmon_ops ym2651y_hwmon_ops = {
+    .is_visible = ym2651y_is_visible,
+};
+
+static const struct hwmon_chip_info ym2651y_chip_info = {
+    .ops = &ym2651y_hwmon_ops,
+    .info = ym2651y_hwmon_info,
+};
+#endif
+
 static int ym2651y_probe(struct i2c_client *client,
             const struct i2c_device_id *dev_id)
 {
@@ -567,7 +599,7 @@ static int ym2651y_probe(struct i2c_client *client,
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4,9,0)
     data->hwmon_dev = hwmon_device_register_with_info(&client->dev, "ym2651y",
-                                                      NULL, NULL, NULL);
+                                        NULL, &ym2651y_chip_info, NULL);
 #else
     data->hwmon_dev = hwmon_device_register(&client->dev);
 #endif
@@ -590,7 +622,11 @@ exit:
     return status;
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6,1,0)
 static int ym2651y_remove(struct i2c_client *client)
+#else
+static void ym2651y_remove(struct i2c_client *client)
+#endif
 {
     struct ym2651y_data *data = i2c_get_clientdata(client);
 
@@ -598,7 +634,9 @@ static int ym2651y_remove(struct i2c_client *client)
     sysfs_remove_group(&client->dev.kobj, &ym2651y_group);
     kfree(data);
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6,1,0)
     return 0;
+#endif
 }
 
 static const struct i2c_device_id ym2651y_id[] = {
diff --git a/packages/platforms/accton/x86-64/as7326-56x/modules/PKG.yml b/packages/platforms/accton/x86-64/as7326-56x/modules/PKG.yml
index 4a30266a..ef0cac8a 100644
--- a/packages/platforms/accton/x86-64/as7326-56x/modules/PKG.yml
+++ b/packages/platforms/accton/x86-64/as7326-56x/modules/PKG.yml
@@ -1 +1 @@
-!include $ONL_TEMPLATES/platform-modules.yml VENDOR=accton BASENAME=x86-64-accton-as7326-56x ARCH=amd64 KERNELS="onl-kernel-4.14-lts-x86-64-all:amd64"
+!include $ONL_TEMPLATES/platform-modules.yml VENDOR=accton BASENAME=x86-64-accton-as7326-56x ARCH=amd64 KERNELS="onl-kernel-6.1-lts-x86-64-all:amd64"
diff --git a/packages/platforms/accton/x86-64/as7326-56x/modules/builds/Makefile b/packages/platforms/accton/x86-64/as7326-56x/modules/builds/Makefile
index 3085e226..26dfa61b 100644
--- a/packages/platforms/accton/x86-64/as7326-56x/modules/builds/Makefile
+++ b/packages/platforms/accton/x86-64/as7326-56x/modules/builds/Makefile
@@ -1,5 +1,5 @@
-KERNELS := onl-kernel-4.14-lts-x86-64-all:amd64
-KMODULES := $(wildcard *.c)
+KERNELS := onl-kernel-6.1-lts-x86-64-all:amd64
+KMODULES := src
 VENDOR := accton
 BASENAME := x86-64-accton-as7326-56x
 ARCH := x86_64
diff --git a/packages/platforms/accton/x86-64/as7326-56x/modules/builds/x86-64-accton-as7326-56x-cpld.c b/packages/platforms/accton/x86-64/as7326-56x/modules/builds/x86-64-accton-as7326-56x-cpld.c
deleted file mode 100644
index 7985f09a..00000000
--- a/packages/platforms/accton/x86-64/as7326-56x/modules/builds/x86-64-accton-as7326-56x-cpld.c
+++ /dev/null
@@ -1,1144 +0,0 @@
-/*
- * Copyright (C)  Brandon Chuang <brandon_chuang@accton.com.tw>
- *
- * This module supports the accton cpld that hold the channel select
- * mechanism for other i2c slave devices, such as SFP.
- * This includes the:
- *	 Accton as7326_56x CPLD1/CPLD2/CPLD3
- *
- * Based on:
- *	pca954x.c from Kumar Gala <galak@kernel.crashing.org>
- * Copyright (C) 2006
- *
- * Based on:
- *	pca954x.c from Ken Harrenstien
- * Copyright (C) 2004 Google, Inc. (Ken Harrenstien)
- *
- * Based on:
- *	i2c-virtual_cb.c from Brian Kuschak <bkuschak@yahoo.com>
- * and
- *	pca9540.c from Jean Delvare <khali@linux-fr.org>.
- *
- * This file is licensed under the terms of the GNU General Public
- * License version 2. This program is licensed "as is" without any
- * warranty of any kind, whether express or implied.
- */
-
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/slab.h>
-#include <linux/device.h>
-#include <linux/i2c.h>
-#include <linux/version.h>
-#include <linux/stat.h>
-#include <linux/hwmon-sysfs.h>
-#include <linux/delay.h>
-
-#define I2C_RW_RETRY_COUNT				10
-#define I2C_RW_RETRY_INTERVAL			60 /* ms */
-
-static LIST_HEAD(cpld_client_list);
-static struct mutex     list_lock;
-
-struct cpld_client_node {
-    struct i2c_client *client;
-    struct list_head   list;
-};
-
-enum cpld_type {
-    as7326_56x_cpld1,
-    as7326_56x_cpld2,
-    as7326_56x_cpld3
-};
-
-struct as7326_56x_cpld_data {
-    enum cpld_type   type;
-    struct device   *hwmon_dev;
-    struct mutex     update_lock;
-};
-
-static const struct i2c_device_id as7326_56x_cpld_id[] = {
-    { "as7326_56x_cpld1", as7326_56x_cpld1 },
-    { "as7326_56x_cpld2", as7326_56x_cpld2 },
-    { "as7326_56x_cpld3", as7326_56x_cpld3 },
-    { }
-};
-MODULE_DEVICE_TABLE(i2c, as7326_56x_cpld_id);
-
-#define TRANSCEIVER_PRESENT_ATTR_ID(index)   	MODULE_PRESENT_##index
-#define TRANSCEIVER_TXDISABLE_ATTR_ID(index)   	MODULE_TXDISABLE_##index
-#define TRANSCEIVER_RXLOS_ATTR_ID(index)   		MODULE_RXLOS_##index
-#define TRANSCEIVER_TXFAULT_ATTR_ID(index)   	MODULE_TXFAULT_##index
-#define TRANSCEIVER_RESET_ATTR_ID(index)   	MODULE_RESET_##index
-
-enum as7326_56x_cpld_sysfs_attributes {
-	CPLD_VERSION,
-	ACCESS,
-	MODULE_PRESENT_ALL,
-	MODULE_RXLOS_ALL,
-	/* transceiver attributes */
-	TRANSCEIVER_PRESENT_ATTR_ID(1),
-	TRANSCEIVER_PRESENT_ATTR_ID(2),
-	TRANSCEIVER_PRESENT_ATTR_ID(3),
-	TRANSCEIVER_PRESENT_ATTR_ID(4),
-	TRANSCEIVER_PRESENT_ATTR_ID(5),
-	TRANSCEIVER_PRESENT_ATTR_ID(6),
-	TRANSCEIVER_PRESENT_ATTR_ID(7),
-	TRANSCEIVER_PRESENT_ATTR_ID(8),
-	TRANSCEIVER_PRESENT_ATTR_ID(9),
-	TRANSCEIVER_PRESENT_ATTR_ID(10),
-	TRANSCEIVER_PRESENT_ATTR_ID(11),
-	TRANSCEIVER_PRESENT_ATTR_ID(12),
-	TRANSCEIVER_PRESENT_ATTR_ID(13),
-	TRANSCEIVER_PRESENT_ATTR_ID(14),
-	TRANSCEIVER_PRESENT_ATTR_ID(15),
-	TRANSCEIVER_PRESENT_ATTR_ID(16),
-	TRANSCEIVER_PRESENT_ATTR_ID(17),
-	TRANSCEIVER_PRESENT_ATTR_ID(18),
-	TRANSCEIVER_PRESENT_ATTR_ID(19),
-	TRANSCEIVER_PRESENT_ATTR_ID(20),
-	TRANSCEIVER_PRESENT_ATTR_ID(21),
-	TRANSCEIVER_PRESENT_ATTR_ID(22),
-	TRANSCEIVER_PRESENT_ATTR_ID(23),
-	TRANSCEIVER_PRESENT_ATTR_ID(24),
-	TRANSCEIVER_PRESENT_ATTR_ID(25),
-	TRANSCEIVER_PRESENT_ATTR_ID(26),
-	TRANSCEIVER_PRESENT_ATTR_ID(27),
-	TRANSCEIVER_PRESENT_ATTR_ID(28),
-	TRANSCEIVER_PRESENT_ATTR_ID(29),
-	TRANSCEIVER_PRESENT_ATTR_ID(30),
-	TRANSCEIVER_PRESENT_ATTR_ID(31),
-	TRANSCEIVER_PRESENT_ATTR_ID(32),
-	TRANSCEIVER_PRESENT_ATTR_ID(33),
-	TRANSCEIVER_PRESENT_ATTR_ID(34),
-	TRANSCEIVER_PRESENT_ATTR_ID(35),
-	TRANSCEIVER_PRESENT_ATTR_ID(36),
-	TRANSCEIVER_PRESENT_ATTR_ID(37),
-	TRANSCEIVER_PRESENT_ATTR_ID(38),
-	TRANSCEIVER_PRESENT_ATTR_ID(39),
-	TRANSCEIVER_PRESENT_ATTR_ID(40),
-	TRANSCEIVER_PRESENT_ATTR_ID(41),
-	TRANSCEIVER_PRESENT_ATTR_ID(42),
-	TRANSCEIVER_PRESENT_ATTR_ID(43),
-	TRANSCEIVER_PRESENT_ATTR_ID(44),
-	TRANSCEIVER_PRESENT_ATTR_ID(45),
-	TRANSCEIVER_PRESENT_ATTR_ID(46),
-	TRANSCEIVER_PRESENT_ATTR_ID(47),
-	TRANSCEIVER_PRESENT_ATTR_ID(48),
-	TRANSCEIVER_PRESENT_ATTR_ID(49),
-	TRANSCEIVER_PRESENT_ATTR_ID(50),
-	TRANSCEIVER_PRESENT_ATTR_ID(51),
-	TRANSCEIVER_PRESENT_ATTR_ID(52),
-	TRANSCEIVER_PRESENT_ATTR_ID(53),
-	TRANSCEIVER_PRESENT_ATTR_ID(54),
-	TRANSCEIVER_PRESENT_ATTR_ID(55),
-	TRANSCEIVER_PRESENT_ATTR_ID(56),
-	TRANSCEIVER_PRESENT_ATTR_ID(57),
-	TRANSCEIVER_PRESENT_ATTR_ID(58),
-	TRANSCEIVER_TXDISABLE_ATTR_ID(1),
-	TRANSCEIVER_TXDISABLE_ATTR_ID(2),
-	TRANSCEIVER_TXDISABLE_ATTR_ID(3),
-	TRANSCEIVER_TXDISABLE_ATTR_ID(4),
-	TRANSCEIVER_TXDISABLE_ATTR_ID(5),
-	TRANSCEIVER_TXDISABLE_ATTR_ID(6),
-	TRANSCEIVER_TXDISABLE_ATTR_ID(7),
-	TRANSCEIVER_TXDISABLE_ATTR_ID(8),
-	TRANSCEIVER_TXDISABLE_ATTR_ID(9),
-	TRANSCEIVER_TXDISABLE_ATTR_ID(10),
-	TRANSCEIVER_TXDISABLE_ATTR_ID(11),
-	TRANSCEIVER_TXDISABLE_ATTR_ID(12),
-	TRANSCEIVER_TXDISABLE_ATTR_ID(13),
-	TRANSCEIVER_TXDISABLE_ATTR_ID(14),
-	TRANSCEIVER_TXDISABLE_ATTR_ID(15),
-	TRANSCEIVER_TXDISABLE_ATTR_ID(16),
-	TRANSCEIVER_TXDISABLE_ATTR_ID(17),
-	TRANSCEIVER_TXDISABLE_ATTR_ID(18),
-	TRANSCEIVER_TXDISABLE_ATTR_ID(19),
-	TRANSCEIVER_TXDISABLE_ATTR_ID(20),
-	TRANSCEIVER_TXDISABLE_ATTR_ID(21),
-	TRANSCEIVER_TXDISABLE_ATTR_ID(22),
-	TRANSCEIVER_TXDISABLE_ATTR_ID(23),
-	TRANSCEIVER_TXDISABLE_ATTR_ID(24),
-	TRANSCEIVER_TXDISABLE_ATTR_ID(25),
-	TRANSCEIVER_TXDISABLE_ATTR_ID(26),
-	TRANSCEIVER_TXDISABLE_ATTR_ID(27),
-	TRANSCEIVER_TXDISABLE_ATTR_ID(28),
-	TRANSCEIVER_TXDISABLE_ATTR_ID(29),
-	TRANSCEIVER_TXDISABLE_ATTR_ID(30),
-	TRANSCEIVER_TXDISABLE_ATTR_ID(31),
-	TRANSCEIVER_TXDISABLE_ATTR_ID(32),
-	TRANSCEIVER_TXDISABLE_ATTR_ID(33),
-	TRANSCEIVER_TXDISABLE_ATTR_ID(34),
-	TRANSCEIVER_TXDISABLE_ATTR_ID(35),
-	TRANSCEIVER_TXDISABLE_ATTR_ID(36),
-	TRANSCEIVER_TXDISABLE_ATTR_ID(37),
-	TRANSCEIVER_TXDISABLE_ATTR_ID(38),
-	TRANSCEIVER_TXDISABLE_ATTR_ID(39),
-	TRANSCEIVER_TXDISABLE_ATTR_ID(40),
-	TRANSCEIVER_TXDISABLE_ATTR_ID(41),
-	TRANSCEIVER_TXDISABLE_ATTR_ID(42),
-	TRANSCEIVER_TXDISABLE_ATTR_ID(43),
-	TRANSCEIVER_TXDISABLE_ATTR_ID(44),
-	TRANSCEIVER_TXDISABLE_ATTR_ID(45),
-	TRANSCEIVER_TXDISABLE_ATTR_ID(46),
-	TRANSCEIVER_TXDISABLE_ATTR_ID(47),
-	TRANSCEIVER_TXDISABLE_ATTR_ID(48),
-	TRANSCEIVER_TXDISABLE_ATTR_ID(57),
-	TRANSCEIVER_TXDISABLE_ATTR_ID(58),
-	TRANSCEIVER_RXLOS_ATTR_ID(1),
-	TRANSCEIVER_RXLOS_ATTR_ID(2),
-	TRANSCEIVER_RXLOS_ATTR_ID(3),
-	TRANSCEIVER_RXLOS_ATTR_ID(4),
-	TRANSCEIVER_RXLOS_ATTR_ID(5),
-	TRANSCEIVER_RXLOS_ATTR_ID(6),
-	TRANSCEIVER_RXLOS_ATTR_ID(7),
-	TRANSCEIVER_RXLOS_ATTR_ID(8),
-	TRANSCEIVER_RXLOS_ATTR_ID(9),
-	TRANSCEIVER_RXLOS_ATTR_ID(10),
-	TRANSCEIVER_RXLOS_ATTR_ID(11),
-	TRANSCEIVER_RXLOS_ATTR_ID(12),
-	TRANSCEIVER_RXLOS_ATTR_ID(13),
-	TRANSCEIVER_RXLOS_ATTR_ID(14),
-	TRANSCEIVER_RXLOS_ATTR_ID(15),
-	TRANSCEIVER_RXLOS_ATTR_ID(16),
-	TRANSCEIVER_RXLOS_ATTR_ID(17),
-	TRANSCEIVER_RXLOS_ATTR_ID(18),
-	TRANSCEIVER_RXLOS_ATTR_ID(19),
-	TRANSCEIVER_RXLOS_ATTR_ID(20),
-	TRANSCEIVER_RXLOS_ATTR_ID(21),
-	TRANSCEIVER_RXLOS_ATTR_ID(22),
-	TRANSCEIVER_RXLOS_ATTR_ID(23),
-	TRANSCEIVER_RXLOS_ATTR_ID(24),
-	TRANSCEIVER_RXLOS_ATTR_ID(25),
-	TRANSCEIVER_RXLOS_ATTR_ID(26),
-	TRANSCEIVER_RXLOS_ATTR_ID(27),
-	TRANSCEIVER_RXLOS_ATTR_ID(28),
-	TRANSCEIVER_RXLOS_ATTR_ID(29),
-	TRANSCEIVER_RXLOS_ATTR_ID(30),
-	TRANSCEIVER_RXLOS_ATTR_ID(31),
-	TRANSCEIVER_RXLOS_ATTR_ID(32),
-	TRANSCEIVER_RXLOS_ATTR_ID(33),
-	TRANSCEIVER_RXLOS_ATTR_ID(34),
-	TRANSCEIVER_RXLOS_ATTR_ID(35),
-	TRANSCEIVER_RXLOS_ATTR_ID(36),
-	TRANSCEIVER_RXLOS_ATTR_ID(37),
-	TRANSCEIVER_RXLOS_ATTR_ID(38),
-	TRANSCEIVER_RXLOS_ATTR_ID(39),
-	TRANSCEIVER_RXLOS_ATTR_ID(40),
-	TRANSCEIVER_RXLOS_ATTR_ID(41),
-	TRANSCEIVER_RXLOS_ATTR_ID(42),
-	TRANSCEIVER_RXLOS_ATTR_ID(43),
-	TRANSCEIVER_RXLOS_ATTR_ID(44),
-	TRANSCEIVER_RXLOS_ATTR_ID(45),
-	TRANSCEIVER_RXLOS_ATTR_ID(46),
-	TRANSCEIVER_RXLOS_ATTR_ID(47),
-	TRANSCEIVER_RXLOS_ATTR_ID(48),
-	TRANSCEIVER_RXLOS_ATTR_ID(57),
-	TRANSCEIVER_RXLOS_ATTR_ID(58),
-	TRANSCEIVER_TXFAULT_ATTR_ID(1),
-	TRANSCEIVER_TXFAULT_ATTR_ID(2),
-	TRANSCEIVER_TXFAULT_ATTR_ID(3),
-	TRANSCEIVER_TXFAULT_ATTR_ID(4),
-	TRANSCEIVER_TXFAULT_ATTR_ID(5),
-	TRANSCEIVER_TXFAULT_ATTR_ID(6),
-	TRANSCEIVER_TXFAULT_ATTR_ID(7),
-	TRANSCEIVER_TXFAULT_ATTR_ID(8),
-	TRANSCEIVER_TXFAULT_ATTR_ID(9),
-	TRANSCEIVER_TXFAULT_ATTR_ID(10),
-	TRANSCEIVER_TXFAULT_ATTR_ID(11),
-	TRANSCEIVER_TXFAULT_ATTR_ID(12),
-	TRANSCEIVER_TXFAULT_ATTR_ID(13),
-	TRANSCEIVER_TXFAULT_ATTR_ID(14),
-	TRANSCEIVER_TXFAULT_ATTR_ID(15),
-	TRANSCEIVER_TXFAULT_ATTR_ID(16),
-	TRANSCEIVER_TXFAULT_ATTR_ID(17),
-	TRANSCEIVER_TXFAULT_ATTR_ID(18),
-	TRANSCEIVER_TXFAULT_ATTR_ID(19),
-	TRANSCEIVER_TXFAULT_ATTR_ID(20),
-	TRANSCEIVER_TXFAULT_ATTR_ID(21),
-	TRANSCEIVER_TXFAULT_ATTR_ID(22),
-	TRANSCEIVER_TXFAULT_ATTR_ID(23),
-	TRANSCEIVER_TXFAULT_ATTR_ID(24),
-	TRANSCEIVER_TXFAULT_ATTR_ID(25),
-	TRANSCEIVER_TXFAULT_ATTR_ID(26),
-	TRANSCEIVER_TXFAULT_ATTR_ID(27),
-	TRANSCEIVER_TXFAULT_ATTR_ID(28),
-	TRANSCEIVER_TXFAULT_ATTR_ID(29),
-	TRANSCEIVER_TXFAULT_ATTR_ID(30),
-	TRANSCEIVER_TXFAULT_ATTR_ID(31),
-	TRANSCEIVER_TXFAULT_ATTR_ID(32),
-	TRANSCEIVER_TXFAULT_ATTR_ID(33),
-	TRANSCEIVER_TXFAULT_ATTR_ID(34),
-	TRANSCEIVER_TXFAULT_ATTR_ID(35),
-	TRANSCEIVER_TXFAULT_ATTR_ID(36),
-	TRANSCEIVER_TXFAULT_ATTR_ID(37),
-	TRANSCEIVER_TXFAULT_ATTR_ID(38),
-	TRANSCEIVER_TXFAULT_ATTR_ID(39),
-	TRANSCEIVER_TXFAULT_ATTR_ID(40),
-	TRANSCEIVER_TXFAULT_ATTR_ID(41),
-	TRANSCEIVER_TXFAULT_ATTR_ID(42),
-	TRANSCEIVER_TXFAULT_ATTR_ID(43),
-	TRANSCEIVER_TXFAULT_ATTR_ID(44),
-	TRANSCEIVER_TXFAULT_ATTR_ID(45),
-	TRANSCEIVER_TXFAULT_ATTR_ID(46),
-	TRANSCEIVER_TXFAULT_ATTR_ID(47),
-	TRANSCEIVER_TXFAULT_ATTR_ID(48),
-	TRANSCEIVER_TXFAULT_ATTR_ID(57),
-	TRANSCEIVER_TXFAULT_ATTR_ID(58),
-};
-
-/* sysfs attributes for hwmon 
- */
-static ssize_t show_status(struct device *dev, struct device_attribute *da,
-             char *buf);
-static ssize_t show_present_all(struct device *dev, struct device_attribute *da,
-             char *buf);
-static ssize_t show_rxlos_all(struct device *dev, struct device_attribute *da,
-             char *buf);
-static ssize_t set_tx_disable(struct device *dev, struct device_attribute *da,
-			const char *buf, size_t count);
-static ssize_t access(struct device *dev, struct device_attribute *da,
-			const char *buf, size_t count);
-static ssize_t show_version(struct device *dev, struct device_attribute *da,
-             char *buf);
-static int as7326_56x_cpld_read_internal(struct i2c_client *client, u8 reg);
-static int as7326_56x_cpld_write_internal(struct i2c_client *client, u8 reg, u8 value);
-
-/* transceiver attributes */
-#define DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(index) \
-	static SENSOR_DEVICE_ATTR(module_present_##index, S_IRUGO, show_status, NULL, MODULE_PRESENT_##index)
-#define DECLARE_TRANSCEIVER_PRESENT_ATTR(index)  &sensor_dev_attr_module_present_##index.dev_attr.attr
-
-#define DECLARE_TRANSCEIVER_RESET_SENSOR_DEVICE_ATTR(index) \
-	static SENSOR_DEVICE_ATTR(module_reset_##index, S_IRUGO | S_IWUSR, show_status, set_reset, MODULE_RESET_##index)
-#define DECLARE_TRANSCEIVER_RESET_ATTR(index)  &sensor_dev_attr_module_reset_##index.dev_attr.attr
-
-#define DECLARE_SFP_TRANSCEIVER_SENSOR_DEVICE_ATTR(index) \
-	static SENSOR_DEVICE_ATTR(module_tx_disable_##index, S_IRUGO | S_IWUSR, show_status, set_tx_disable, MODULE_TXDISABLE_##index); \
-	static SENSOR_DEVICE_ATTR(module_rx_los_##index, S_IRUGO, show_status, NULL, MODULE_RXLOS_##index); \
-	static SENSOR_DEVICE_ATTR(module_tx_fault_##index, S_IRUGO, show_status, NULL, MODULE_TXFAULT_##index)
-#define DECLARE_SFP_TRANSCEIVER_ATTR(index)  \
-	&sensor_dev_attr_module_tx_disable_##index.dev_attr.attr, \
-	&sensor_dev_attr_module_rx_los_##index.dev_attr.attr, \
-	&sensor_dev_attr_module_tx_fault_##index.dev_attr.attr
-
-static SENSOR_DEVICE_ATTR(version, S_IRUGO, show_version, NULL, CPLD_VERSION);
-static SENSOR_DEVICE_ATTR(access, S_IWUSR, NULL, access, ACCESS);
-/* transceiver attributes */
-static SENSOR_DEVICE_ATTR(module_present_all, S_IRUGO, show_present_all, NULL, MODULE_PRESENT_ALL);
-static SENSOR_DEVICE_ATTR(module_rx_los_all, S_IRUGO, show_rxlos_all, NULL, MODULE_RXLOS_ALL);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(1);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(2);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(3);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(4);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(5);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(6);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(7);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(8);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(9);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(10);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(11);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(12);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(13);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(14);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(15);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(16);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(17);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(18);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(19);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(20);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(21);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(22);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(23);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(24);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(25);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(26);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(27);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(28);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(29);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(30);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(31);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(32);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(33);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(34);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(35);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(36);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(37);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(38);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(39);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(40);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(41);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(42);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(43);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(44);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(45);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(46);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(47);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(48);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(49);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(50);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(51);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(52);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(53);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(54);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(55);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(56);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(57);
-DECLARE_TRANSCEIVER_PRESENT_SENSOR_DEVICE_ATTR(58);
-
-DECLARE_SFP_TRANSCEIVER_SENSOR_DEVICE_ATTR(1);
-DECLARE_SFP_TRANSCEIVER_SENSOR_DEVICE_ATTR(2);
-DECLARE_SFP_TRANSCEIVER_SENSOR_DEVICE_ATTR(3);
-DECLARE_SFP_TRANSCEIVER_SENSOR_DEVICE_ATTR(4);
-DECLARE_SFP_TRANSCEIVER_SENSOR_DEVICE_ATTR(5);
-DECLARE_SFP_TRANSCEIVER_SENSOR_DEVICE_ATTR(6);
-DECLARE_SFP_TRANSCEIVER_SENSOR_DEVICE_ATTR(7);
-DECLARE_SFP_TRANSCEIVER_SENSOR_DEVICE_ATTR(8);
-DECLARE_SFP_TRANSCEIVER_SENSOR_DEVICE_ATTR(9);
-DECLARE_SFP_TRANSCEIVER_SENSOR_DEVICE_ATTR(10);
-DECLARE_SFP_TRANSCEIVER_SENSOR_DEVICE_ATTR(11);
-DECLARE_SFP_TRANSCEIVER_SENSOR_DEVICE_ATTR(12);
-DECLARE_SFP_TRANSCEIVER_SENSOR_DEVICE_ATTR(13);
-DECLARE_SFP_TRANSCEIVER_SENSOR_DEVICE_ATTR(14);
-DECLARE_SFP_TRANSCEIVER_SENSOR_DEVICE_ATTR(15);
-DECLARE_SFP_TRANSCEIVER_SENSOR_DEVICE_ATTR(16);
-DECLARE_SFP_TRANSCEIVER_SENSOR_DEVICE_ATTR(17);
-DECLARE_SFP_TRANSCEIVER_SENSOR_DEVICE_ATTR(18);
-DECLARE_SFP_TRANSCEIVER_SENSOR_DEVICE_ATTR(19);
-DECLARE_SFP_TRANSCEIVER_SENSOR_DEVICE_ATTR(20);
-DECLARE_SFP_TRANSCEIVER_SENSOR_DEVICE_ATTR(21);
-DECLARE_SFP_TRANSCEIVER_SENSOR_DEVICE_ATTR(22);
-DECLARE_SFP_TRANSCEIVER_SENSOR_DEVICE_ATTR(23);
-DECLARE_SFP_TRANSCEIVER_SENSOR_DEVICE_ATTR(24);
-DECLARE_SFP_TRANSCEIVER_SENSOR_DEVICE_ATTR(25);
-DECLARE_SFP_TRANSCEIVER_SENSOR_DEVICE_ATTR(26);
-DECLARE_SFP_TRANSCEIVER_SENSOR_DEVICE_ATTR(27);
-DECLARE_SFP_TRANSCEIVER_SENSOR_DEVICE_ATTR(28);
-DECLARE_SFP_TRANSCEIVER_SENSOR_DEVICE_ATTR(29);
-DECLARE_SFP_TRANSCEIVER_SENSOR_DEVICE_ATTR(30);
-DECLARE_SFP_TRANSCEIVER_SENSOR_DEVICE_ATTR(31);
-DECLARE_SFP_TRANSCEIVER_SENSOR_DEVICE_ATTR(32);
-DECLARE_SFP_TRANSCEIVER_SENSOR_DEVICE_ATTR(33);
-DECLARE_SFP_TRANSCEIVER_SENSOR_DEVICE_ATTR(34);
-DECLARE_SFP_TRANSCEIVER_SENSOR_DEVICE_ATTR(35);
-DECLARE_SFP_TRANSCEIVER_SENSOR_DEVICE_ATTR(36);
-DECLARE_SFP_TRANSCEIVER_SENSOR_DEVICE_ATTR(37);
-DECLARE_SFP_TRANSCEIVER_SENSOR_DEVICE_ATTR(38);
-DECLARE_SFP_TRANSCEIVER_SENSOR_DEVICE_ATTR(39);
-DECLARE_SFP_TRANSCEIVER_SENSOR_DEVICE_ATTR(40);
-DECLARE_SFP_TRANSCEIVER_SENSOR_DEVICE_ATTR(41);
-DECLARE_SFP_TRANSCEIVER_SENSOR_DEVICE_ATTR(42);
-DECLARE_SFP_TRANSCEIVER_SENSOR_DEVICE_ATTR(43);
-DECLARE_SFP_TRANSCEIVER_SENSOR_DEVICE_ATTR(44);
-DECLARE_SFP_TRANSCEIVER_SENSOR_DEVICE_ATTR(45);
-DECLARE_SFP_TRANSCEIVER_SENSOR_DEVICE_ATTR(46);
-DECLARE_SFP_TRANSCEIVER_SENSOR_DEVICE_ATTR(47);
-DECLARE_SFP_TRANSCEIVER_SENSOR_DEVICE_ATTR(48);
-DECLARE_SFP_TRANSCEIVER_SENSOR_DEVICE_ATTR(57);
-DECLARE_SFP_TRANSCEIVER_SENSOR_DEVICE_ATTR(58);
-
-static struct attribute *as7326_56x_cpld3_attributes[] = {
-    &sensor_dev_attr_version.dev_attr.attr,
-    &sensor_dev_attr_access.dev_attr.attr,
-	NULL
-};
-
-static const struct attribute_group as7326_56x_cpld3_group = {
-	.attrs = as7326_56x_cpld3_attributes,
-};
-
-static struct attribute *as7326_56x_cpld2_attributes[] = {
-    &sensor_dev_attr_version.dev_attr.attr,
-    &sensor_dev_attr_access.dev_attr.attr,
-	/* transceiver attributes */
-	&sensor_dev_attr_module_present_all.dev_attr.attr,
-	&sensor_dev_attr_module_rx_los_all.dev_attr.attr,
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(1),
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(2),
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(3),
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(4),
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(5),
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(6),
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(7),
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(8),
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(9),
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(10),
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(11),
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(12),
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(13),
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(14),
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(15),
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(16),
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(17),
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(18),
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(19),
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(20),
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(21),
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(22),
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(23),
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(24),
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(25),
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(26),
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(27),
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(28),
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(29),
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(30),
-	DECLARE_SFP_TRANSCEIVER_ATTR(1),
-	DECLARE_SFP_TRANSCEIVER_ATTR(2),
-	DECLARE_SFP_TRANSCEIVER_ATTR(3),
-	DECLARE_SFP_TRANSCEIVER_ATTR(4),
-	DECLARE_SFP_TRANSCEIVER_ATTR(5),
-	DECLARE_SFP_TRANSCEIVER_ATTR(6),
-	DECLARE_SFP_TRANSCEIVER_ATTR(7),
-	DECLARE_SFP_TRANSCEIVER_ATTR(8),
-	DECLARE_SFP_TRANSCEIVER_ATTR(9),
-	DECLARE_SFP_TRANSCEIVER_ATTR(10),
-	DECLARE_SFP_TRANSCEIVER_ATTR(11),
-	DECLARE_SFP_TRANSCEIVER_ATTR(12),
-	DECLARE_SFP_TRANSCEIVER_ATTR(13),
-	DECLARE_SFP_TRANSCEIVER_ATTR(14),
-	DECLARE_SFP_TRANSCEIVER_ATTR(15),
-	DECLARE_SFP_TRANSCEIVER_ATTR(16),
-	DECLARE_SFP_TRANSCEIVER_ATTR(17),
-	DECLARE_SFP_TRANSCEIVER_ATTR(18),
-	DECLARE_SFP_TRANSCEIVER_ATTR(19),
-	DECLARE_SFP_TRANSCEIVER_ATTR(20),
-	DECLARE_SFP_TRANSCEIVER_ATTR(21),
-	DECLARE_SFP_TRANSCEIVER_ATTR(22),
-	DECLARE_SFP_TRANSCEIVER_ATTR(23),
-	DECLARE_SFP_TRANSCEIVER_ATTR(24),
-    	DECLARE_SFP_TRANSCEIVER_ATTR(25),
-	DECLARE_SFP_TRANSCEIVER_ATTR(26),
-	DECLARE_SFP_TRANSCEIVER_ATTR(27),
-	DECLARE_SFP_TRANSCEIVER_ATTR(28),
-	DECLARE_SFP_TRANSCEIVER_ATTR(29),
-	DECLARE_SFP_TRANSCEIVER_ATTR(30),
-	NULL
-};
-
-static const struct attribute_group as7326_56x_cpld2_group = {
-	.attrs = as7326_56x_cpld2_attributes,
-};
-
-static struct attribute *as7326_56x_cpld1_attributes[] = {
-    &sensor_dev_attr_version.dev_attr.attr,
-    &sensor_dev_attr_access.dev_attr.attr,
-	/* transceiver attributes */
-	&sensor_dev_attr_module_present_all.dev_attr.attr,
-	&sensor_dev_attr_module_rx_los_all.dev_attr.attr,
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(31),
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(32),
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(33),
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(34),
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(35),
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(36),
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(37),
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(38),
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(39),
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(40),
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(41),
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(42),
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(43),
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(44),
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(45),
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(46),
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(47),
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(48),
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(49),
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(50),
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(51),
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(52),
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(53),
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(54),
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(55),
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(56),
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(57),
-	DECLARE_TRANSCEIVER_PRESENT_ATTR(58),
-	DECLARE_SFP_TRANSCEIVER_ATTR(31),
-	DECLARE_SFP_TRANSCEIVER_ATTR(32),
-	DECLARE_SFP_TRANSCEIVER_ATTR(33),
-	DECLARE_SFP_TRANSCEIVER_ATTR(34),
-	DECLARE_SFP_TRANSCEIVER_ATTR(35),
-	DECLARE_SFP_TRANSCEIVER_ATTR(36),
-	DECLARE_SFP_TRANSCEIVER_ATTR(37),
-	DECLARE_SFP_TRANSCEIVER_ATTR(38),
-	DECLARE_SFP_TRANSCEIVER_ATTR(39),
-	DECLARE_SFP_TRANSCEIVER_ATTR(40),
-	DECLARE_SFP_TRANSCEIVER_ATTR(41),
-	DECLARE_SFP_TRANSCEIVER_ATTR(42),
-	DECLARE_SFP_TRANSCEIVER_ATTR(43),
-	DECLARE_SFP_TRANSCEIVER_ATTR(44),
-	DECLARE_SFP_TRANSCEIVER_ATTR(45),
-	DECLARE_SFP_TRANSCEIVER_ATTR(46),
-	DECLARE_SFP_TRANSCEIVER_ATTR(47),
-	DECLARE_SFP_TRANSCEIVER_ATTR(48),
-	DECLARE_SFP_TRANSCEIVER_ATTR(57),
-	DECLARE_SFP_TRANSCEIVER_ATTR(58),
-	NULL
-};
-
-static const struct attribute_group as7326_56x_cpld1_group = {
-	.attrs = as7326_56x_cpld1_attributes,
-};
-
-/*Split a number into bytes and insert blank between any 2 of bytes.*/
-static int string_byte_sep(char *out, int bits, u64 bytes)
-{ 
-    int i;
-    char sb[8];
-   
-    if (!out) 
-        return -EINVAL;
-
-    out[0] = 0; 
-    for (i = 0; i < ((bits+7)/8); i++) {
-        sprintf(sb, "%02llx ", (bytes>>(i*8))&0xff);
-        strncat(out, sb, strlen(sb));
-    }
-    out[strlen(out)-1] = 0;
-
-    return 0;
-}
-
-static ssize_t show_present_all(struct device *dev, struct device_attribute *da,
-             char *buf)
-{
-    int i, status;
-    u64 values = 0, num;
-    struct i2c_client *client = to_i2c_client(dev);
-    struct as7326_56x_cpld_data *data = i2c_get_clientdata(client);
-
-    if (data->type == as7326_56x_cpld2) {
-        u8 byte;
-        u8 regs[] = {0x0F, 0x10, 0x11, 0x12};
-
-        mutex_lock(&data->update_lock);
-        for (i = 0; i < ARRAY_SIZE(regs); i++) {
-            status = as7326_56x_cpld_read_internal(client, regs[i]);
-        
-            if (status < 0) {
-                goto exit;
-            }
-            byte= (u64)status;
-            byte= ~byte;
-            values |= (byte)<<(i*8);
-        }
-        mutex_unlock(&data->update_lock);
-
-        /* Return values for port 1~30 in order */
-        num = 30;
-        values &= (1<<num)-1;
-    }
-    else { /* as7326_56x_cpld1 */
-        u8 regs[] = {0x10, 0x11, 0x12, 0x13};
-        u8 bytes[4] = {0};
-
-        mutex_lock(&data->update_lock);
-        for (i = 0; i < ARRAY_SIZE(regs); i++) {
-            status = as7326_56x_cpld_read_internal(client, regs[i]);
-            if (status < 0) {
-                goto exit;
-            }
-            bytes[i] = (u8)status;
-            bytes[i] = ~bytes[i];
-        }
-        mutex_unlock(&data->update_lock);
-
-        /* Return values of port 31 -> 58 in order */
-        values = bytes[0] | (bytes[1]<<8) | ((bytes[2]&0x3)<<16) | ((bytes[3])<<18) | 
-                (((bytes[2]&0xC) >> 2)<<26);
-        num = 28;
-        values &= (1<<num)-1;
-    }
-    string_byte_sep(buf, num, values);
-    return sprintf(buf, "%s", buf);
-exit:
-    mutex_unlock(&data->update_lock);
-    return status;
-}
-
-static ssize_t show_rxlos_all(struct device *dev, struct device_attribute *da,
-             char *buf)
-{
-    int i, status;
-    u64 values = 0, num;
-    struct i2c_client *client = to_i2c_client(dev);
-    struct as7326_56x_cpld_data *data = i2c_get_clientdata(client);
-
-    if (data->type == as7326_56x_cpld2) {
-        u8 byte;
-        u8 regs[] = {0x0B, 0x0C, 0x0D, 0x0E};
-
-        mutex_lock(&data->update_lock);
-        for (i = 0; i < ARRAY_SIZE(regs); i++) {
-            status = as7326_56x_cpld_read_internal(client, regs[i]);
-        
-            if (status < 0) {
-                goto exit;
-            }
-            byte= (u64)status;
-            values |= (byte)<<(i*8);
-        }
-        mutex_unlock(&data->update_lock);
-
-        /* Return values for port 1~30 in order */
-        num = 30;
-        values &= (1<<num)-1;
-
-    }
-    else { /* as7326_56x_cpld1 */
-        u8 regs[] = {0x17, 0x18, 0x19};
-        u8 bytes[4] = {0};
-
-        mutex_lock(&data->update_lock);
-        for (i = 0; i < ARRAY_SIZE(regs); i++) {
-            status = as7326_56x_cpld_read_internal(client, regs[i]);
-        
-            if (status < 0) {
-                goto exit;
-            }
-            bytes[i] = (u8)status;
-        }
-        mutex_unlock(&data->update_lock);
-
-        /* Return values of port 31 -> 58 in order */
-        values = bytes[0] | (bytes[1]<<8) | ((bytes[2]&0x3)<<16) |
-                (((bytes[2]&0xC) >> 2)<<26);
-
-        num = 28;
-        values &= (1<<num)-1;
-    }
-    string_byte_sep(buf, num, values);
-    return sprintf(buf, "%s", buf);
-exit:
-    mutex_unlock(&data->update_lock);
-    return status;
-}
-
-static ssize_t show_status(struct device *dev, struct device_attribute *da,
-             char *buf)
-{
-    struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
-    struct i2c_client *client = to_i2c_client(dev);
-    struct as7326_56x_cpld_data *data = i2c_get_clientdata(client);
-	int status = 0;
-	u8 reg = 0, mask = 0, revert = 0;
-
-	switch (attr->index) {
-	case MODULE_PRESENT_1 ... MODULE_PRESENT_30:
-		reg  = 0x0f + (attr->index-MODULE_PRESENT_1)/8;
-		mask = 0x1 << ((attr->index - MODULE_PRESENT_1)%8);
-		break;
-	case MODULE_PRESENT_31 ... MODULE_PRESENT_48:
-		reg  = 0x10 + (attr->index-MODULE_PRESENT_31)/8;
-		mask = 0x1 << ((attr->index - MODULE_PRESENT_31)%8);
-		break;
-	case MODULE_PRESENT_57 ... MODULE_PRESENT_58:
-		reg  = 0x12;
-		mask = 0x1 << ((attr->index - MODULE_PRESENT_57)+2);
-		break;
-	case MODULE_PRESENT_49 ... MODULE_PRESENT_56:   /*QSFP*/
-		reg  = 0x13 ;
-		mask = 0x1 << ((attr->index - MODULE_PRESENT_49)%8);
-		break;
-	case MODULE_TXFAULT_1 ... MODULE_TXFAULT_30:
-		reg  = 0x03 + (attr->index - MODULE_TXFAULT_1)/8;
-		mask = 0x1 << ((attr->index - MODULE_TXFAULT_1)%8);
-		break;
-	case MODULE_TXFAULT_31 ... MODULE_TXFAULT_48:
-		reg  = 0x1a + (attr->index-MODULE_TXFAULT_31)/8;
-		mask = 0x1 << ((attr->index - MODULE_TXFAULT_31)%8);
-		break;
-	case MODULE_TXFAULT_57 ... MODULE_TXFAULT_58:
-		reg  = 0x1c;
-		mask = 0x1 << (( attr->index - MODULE_TXFAULT_57)+2);
-		break;
-	case MODULE_TXDISABLE_1 ... MODULE_TXDISABLE_30:
-		reg  = 0x07 + (attr->index - MODULE_TXDISABLE_1)/8;
-		mask = 0x1 << ((attr->index - MODULE_TXDISABLE_1)%8);
-		break;
-	case MODULE_TXDISABLE_31 ... MODULE_TXDISABLE_48:
-		reg  = 0x14 + (attr->index-MODULE_TXDISABLE_31)/8;
-		mask = 0x1 << ((attr->index - MODULE_TXDISABLE_31)%8);
-		break;
-	case MODULE_TXDISABLE_57 ... MODULE_TXDISABLE_58:
-		reg  = 0x16;
-		mask = 0x1 << ((attr->index - MODULE_TXDISABLE_57)+2);
-		break;
-	case MODULE_RXLOS_1 ... MODULE_RXLOS_30:
-		reg  = 0x0b + (attr->index - MODULE_RXLOS_1)/8;
-		mask = 0x1 << ((attr->index - MODULE_RXLOS_1)%8);
-		break;
-	case MODULE_RXLOS_31 ... MODULE_RXLOS_48:
-		reg  = 0x17 + (attr->index-MODULE_RXLOS_31)/8;
-		mask = 0x1 << ((attr->index - MODULE_RXLOS_31)%8);
-		break;
-	case MODULE_RXLOS_57 ... MODULE_RXLOS_58:
-		reg  = 0x19;
-		mask = 0x1 << (( attr->index - MODULE_RXLOS_57)+2);
-		break;
-	default:
-		return 0;
-	}
-
-    if (attr->index >= MODULE_PRESENT_1 && attr->index <= MODULE_PRESENT_58) {
-        revert = 1;
-    }
-
-    mutex_lock(&data->update_lock);
-	status = as7326_56x_cpld_read_internal(client, reg);
-	if (unlikely(status < 0)) {
-		goto exit;
-	}
-	mutex_unlock(&data->update_lock);
-
-	return sprintf(buf, "%d\n", revert ? !(status & mask) : !!(status & mask));
-
-exit:
-	mutex_unlock(&data->update_lock);
-	return status;
-}
-
-static ssize_t set_tx_disable(struct device *dev, struct device_attribute *da,
-			const char *buf, size_t count)
-{
-    struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
-	struct i2c_client *client = to_i2c_client(dev);
-	struct as7326_56x_cpld_data *data = i2c_get_clientdata(client);
-	long disable;
-	int status;
-    u8 reg = 0, mask = 0;
-
-	status = kstrtol(buf, 10, &disable);
-	if (status) {
-		return status;
-	}
-
-	switch (attr->index) {
-	case MODULE_TXDISABLE_1 ... MODULE_TXDISABLE_30:
-		reg  = 0x07 + (attr->index - MODULE_TXDISABLE_1)/8;
-		mask = 0x1 << ((attr->index - MODULE_TXDISABLE_1)%8);
-		break;
-	case MODULE_TXDISABLE_31 ... MODULE_TXDISABLE_48:
-		reg  = 0x14 + (attr->index - MODULE_TXDISABLE_31)/8;
-		mask = 0x1 << ((attr->index - MODULE_TXDISABLE_31)%8);
-		break;
-	case MODULE_TXDISABLE_57 ... MODULE_TXDISABLE_58:
-		reg  = 0x16;
-		mask = 0x1 << ((attr->index - MODULE_TXDISABLE_57)+2);
-		break;
-	default:
-		return 0;
-	}
-
-    /* Read current status */
-    mutex_lock(&data->update_lock);
-	status = as7326_56x_cpld_read_internal(client, reg);
-	if (unlikely(status < 0)) {
-		goto exit;
-	}
-
-	/* Update tx_disable status */
-	if (disable) {
-		status |= mask;
-	}
-	else {
-		status &= ~mask;
-	}
-
-        status = as7326_56x_cpld_write_internal(client, reg, status);
-	if (unlikely(status < 0)) {
-		goto exit;
-	}
-    
-    mutex_unlock(&data->update_lock);
-    return count;
-
-exit:
-	mutex_unlock(&data->update_lock);
-	return status;
-}
-
-static ssize_t access(struct device *dev, struct device_attribute *da,
-			const char *buf, size_t count)
-{
-	int status;
-	u32 addr, val;
-    struct i2c_client *client = to_i2c_client(dev);
-    struct as7326_56x_cpld_data *data = i2c_get_clientdata(client);
-
-	if (sscanf(buf, "0x%x 0x%x", &addr, &val) != 2) {
-		return -EINVAL;
-	}
-
-	if (addr > 0xFF || val > 0xFF) {
-		return -EINVAL;
-	}
-
-	mutex_lock(&data->update_lock);
-	status = as7326_56x_cpld_write_internal(client, addr, val);
-	if (unlikely(status < 0)) {
-		goto exit;
-	}
-	mutex_unlock(&data->update_lock);
-	return count;
-
-exit:
-	mutex_unlock(&data->update_lock);
-	return status;
-}
-
-static void as7326_56x_cpld_add_client(struct i2c_client *client)
-{
-    struct cpld_client_node *node = kzalloc(sizeof(struct cpld_client_node), GFP_KERNEL);
-
-    if (!node) {
-        dev_dbg(&client->dev, "Can't allocate cpld_client_node (0x%x)\n", client->addr);
-        return;
-    }
-
-    node->client = client;
-
-	mutex_lock(&list_lock);
-    list_add(&node->list, &cpld_client_list);
-	mutex_unlock(&list_lock);
-}
-
-static void as7326_56x_cpld_remove_client(struct i2c_client *client)
-{
-    struct list_head    *list_node = NULL;
-    struct cpld_client_node *cpld_node = NULL;
-    int found = 0;
-
-	mutex_lock(&list_lock);
-
-    list_for_each(list_node, &cpld_client_list)
-    {
-        cpld_node = list_entry(list_node, struct cpld_client_node, list);
-
-        if (cpld_node->client == client) {
-            found = 1;
-            break;
-        }
-    }
-
-    if (found) {
-        list_del(list_node);
-        kfree(cpld_node);
-    }
-
-	mutex_unlock(&list_lock);
-}
-
-static ssize_t show_version(struct device *dev, struct device_attribute *attr, char *buf)
-{
-    int val = 0;
-    struct i2c_client *client = to_i2c_client(dev);
-	
-	val = i2c_smbus_read_byte_data(client, 0x1);
-
-    if (val < 0) {
-        dev_dbg(&client->dev, "cpld(0x%x) reg(0x1) err %d\n", client->addr, val);
-    }
-	
-    return sprintf(buf, "%d", val);
-}
-
-/*
- * I2C init/probing/exit functions
- */
-static int as7326_56x_cpld_probe(struct i2c_client *client,
-			 const struct i2c_device_id *id)
-{
-	struct i2c_adapter *adap = to_i2c_adapter(client->dev.parent);
-	struct as7326_56x_cpld_data *data;
-	int ret = -ENODEV;
-	const struct attribute_group *group = NULL;
-
-	if (!i2c_check_functionality(adap, I2C_FUNC_SMBUS_BYTE))
-		goto exit;
-
-	data = kzalloc(sizeof(struct as7326_56x_cpld_data), GFP_KERNEL);
-	if (!data) {
-		ret = -ENOMEM;
-		goto exit;
-	}
-
-	i2c_set_clientdata(client, data);
-    mutex_init(&data->update_lock);
-	data->type = id->driver_data;
-
-    /* Register sysfs hooks */
-    switch (data->type) {
-    case as7326_56x_cpld1:
-        group = &as7326_56x_cpld1_group;
-        break;
-    case as7326_56x_cpld2:
-        group = &as7326_56x_cpld2_group;
-        break;
-	case as7326_56x_cpld3:
-        group = &as7326_56x_cpld3_group;
-        break;
-    default:
-        break;
-    }
-
-    if (group) {
-        ret = sysfs_create_group(&client->dev.kobj, group);
-        if (ret) {
-            goto exit_free;
-        }
-    }
-
-    as7326_56x_cpld_add_client(client);
-    return 0;
-
-exit_free:
-    kfree(data);
-exit:
-	return ret;
-}
-
-static int as7326_56x_cpld_remove(struct i2c_client *client)
-{
-    struct as7326_56x_cpld_data *data = i2c_get_clientdata(client);
-    const struct attribute_group *group = NULL;
-
-    as7326_56x_cpld_remove_client(client);
-
-    /* Remove sysfs hooks */
-    switch (data->type) {
-    case as7326_56x_cpld1:
-        group = &as7326_56x_cpld1_group;
-        break;
-    case as7326_56x_cpld2:
-        group = &as7326_56x_cpld2_group;
-        break;
-	case as7326_56x_cpld3:
-        group = &as7326_56x_cpld3_group;
-        break;
-    default:
-        break;
-    }
-
-    if (group) {
-        sysfs_remove_group(&client->dev.kobj, group);
-    }
-
-    kfree(data);
-
-    return 0;
-}
-
-static int as7326_56x_cpld_read_internal(struct i2c_client *client, u8 reg)
-{
-	int status = 0, retry = I2C_RW_RETRY_COUNT;
-
-	while (retry) {
-		status = i2c_smbus_read_byte_data(client, reg);
-		if (unlikely(status < 0)) {
-			msleep(I2C_RW_RETRY_INTERVAL);
-			retry--;
-			continue;
-		}
-
-		break;
-	}
-
-    return status;
-}
-
-static int as7326_56x_cpld_write_internal(struct i2c_client *client, u8 reg, u8 value)
-{
-	int status = 0, retry = I2C_RW_RETRY_COUNT;
-
-	while (retry) {
-		status = i2c_smbus_write_byte_data(client, reg, value);
-		if (unlikely(status < 0)) {
-			msleep(I2C_RW_RETRY_INTERVAL);
-			retry--;
-			continue;
-		}
-
-		break;
-	}
-
-    return status;
-}
-
-int as7326_56x_cpld_read(unsigned short cpld_addr, u8 reg)
-{
-    struct list_head   *list_node = NULL;
-    struct cpld_client_node *cpld_node = NULL;
-    int ret = -EPERM;
-
-    mutex_lock(&list_lock);
-
-    list_for_each(list_node, &cpld_client_list)
-    {
-        cpld_node = list_entry(list_node, struct cpld_client_node, list);
-
-        if (cpld_node->client->addr == cpld_addr) {
-            ret = as7326_56x_cpld_read_internal(cpld_node->client, reg);
-    		break;
-        }
-    }
-
-	mutex_unlock(&list_lock);
-
-    return ret;
-}
-EXPORT_SYMBOL(as7326_56x_cpld_read);
-
-int as7326_56x_cpld_write(unsigned short cpld_addr, u8 reg, u8 value)
-{
-    struct list_head   *list_node = NULL;
-    struct cpld_client_node *cpld_node = NULL;
-    int ret = -EIO;
-
-	mutex_lock(&list_lock);
-
-    list_for_each(list_node, &cpld_client_list)
-    {
-        cpld_node = list_entry(list_node, struct cpld_client_node, list);
-
-        if (cpld_node->client->addr == cpld_addr) {
-            ret = as7326_56x_cpld_write_internal(cpld_node->client, reg, value);
-            break;
-        }
-    }
-
-	mutex_unlock(&list_lock);
-
-    return ret;
-}
-EXPORT_SYMBOL(as7326_56x_cpld_write);
-
-static struct i2c_driver as7326_56x_cpld_driver = {
-	.driver		= {
-		.name	= "as7326_56x_cpld",
-		.owner	= THIS_MODULE,
-	},
-	.probe		= as7326_56x_cpld_probe,
-	.remove		= as7326_56x_cpld_remove,
-	.id_table	= as7326_56x_cpld_id,
-};
-
-static int __init as7326_56x_cpld_init(void)
-{
-    mutex_init(&list_lock);
-    return i2c_add_driver(&as7326_56x_cpld_driver);
-}
-
-static void __exit as7326_56x_cpld_exit(void)
-{
-    i2c_del_driver(&as7326_56x_cpld_driver);
-}
-
-MODULE_AUTHOR("Brandon Chuang <brandon_chuang@accton.com.tw>");
-MODULE_DESCRIPTION("Accton I2C CPLD driver");
-MODULE_LICENSE("GPL");
-
-module_init(as7326_56x_cpld_init);
-module_exit(as7326_56x_cpld_exit);
-
diff --git a/packages/platforms/accton/x86-64/as7326-56x/modules/builds/x86-64-accton-as7326-56x-fan.c b/packages/platforms/accton/x86-64/as7326-56x/modules/builds/x86-64-accton-as7326-56x-fan.c
deleted file mode 100644
index 69364115..00000000
--- a/packages/platforms/accton/x86-64/as7326-56x/modules/builds/x86-64-accton-as7326-56x-fan.c
+++ /dev/null
@@ -1,970 +0,0 @@
-/*
- * A hwmon driver for the Accton as7326 56x fan
- *
- * Copyright (C) 2014 Accton Technology Corporation.
- * Brandon Chuang <brandon_chuang@accton.com.tw>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
-
-#include <linux/module.h>
-#include <linux/jiffies.h>
-#include <linux/i2c.h>
-#include <linux/hwmon.h>
-#include <linux/hwmon-sysfs.h>
-#include <linux/err.h>
-#include <linux/mutex.h>
-#include <linux/sysfs.h>
-#include <linux/slab.h>
-#include <linux/dmi.h>
-#include <linux/fs.h>
-#include <asm/uaccess.h>
-
-#define DRVNAME "as7326_56x_fan"
-
-#define NUM_THERMAL_SENSORS     (3)     /* Get sum of this number of sensors.*/
-#define THERMAL_SENSORS_DRIVER     "lm75"
-#define THERMAL_SENSORS_ADDRS   {0x48, 0x49, 0x4a}
-
-#define		IN
-#define		OUT
-
-static struct as7326_56x_fan_data *as7326_56x_fan_update_device(struct device *dev);
-static ssize_t fan_show_value(struct device *dev, struct device_attribute *da, char *buf);
-static ssize_t set_duty_cycle(struct device *dev, struct device_attribute *da,
-                              const char *buf, size_t count);
-static ssize_t set_wdt_status(struct device *dev, struct device_attribute *da,
-                                const char *buf, size_t count);
-static ssize_t set_wdt_timer(struct device *dev, struct device_attribute *da,
-                                const char *buf, size_t count);
-static ssize_t set_wdt_max_pwm(struct device *dev, struct device_attribute *da,
-                                const char *buf, size_t count);
-static ssize_t show_wdt_status(struct device *dev, struct device_attribute *da, char *buf);
-static ssize_t show_wdt_timer(struct device *dev, struct device_attribute *da, char *buf);
-static ssize_t show_wdt_max_pwm(struct device *dev, struct device_attribute *da, char *buf);
-static ssize_t get_enable(struct device *dev, struct device_attribute *da, char *buf);
-static ssize_t set_enable(struct device *dev, struct device_attribute *da,
-                          const char *buf, size_t count);
-static ssize_t get_sys_temp(struct device *dev, struct device_attribute *da, char *buf);
-extern int accton_i2c_cpld_read(unsigned short cpld_addr, u8 reg);
-extern int accton_i2c_cpld_write(unsigned short cpld_addr, u8 reg, u8 value);
-
-/* fan related data, the index should match sysfs_fan_attributes
- */
-static const u8 fan_reg[] = {
-    0x0F,       /* fan 1-6 present status */
-    0x10,	    /* fan 1-6 direction(0:F2B 1:B2F) */
-    0x11,       /* fan PWM(for all fan) */
-    0x12,       /* front fan 1 speed(rpm) */
-    0x13,       /* front fan 2 speed(rpm) */
-    0x14,       /* front fan 3 speed(rpm) */
-    0x15,       /* front fan 4 speed(rpm) */
-    0x16,       /* front fan 5 speed(rpm) */
-    0x17,       /* front fan 6 speed(rpm) */
-    0x22,       /* rear fan 1 speed(rpm) */
-    0x23,       /* rear fan 2 speed(rpm) */
-    0x24,       /* rear fan 3 speed(rpm) */
-    0x25,       /* rear fan 4 speed(rpm) */
-    0x26,       /* rear fan 5 speed(rpm) */
-    0x27,       /* rear fan 6 speed(rpm) */
-    0x31,       /* watchdog timer */
-    0x32,       /* watchdog maximum PWM value */
-    0x33,       /* watchdog disable */
-};
-
-/* Each client has this additional data */
-struct as7326_56x_fan_data {
-    struct device   *hwmon_dev;
-    struct mutex     update_lock;
-    char             valid;           /* != 0 if registers are valid */
-    unsigned long    last_updated;    /* In jiffies */
-    u8               reg_val[ARRAY_SIZE(fan_reg)]; /* Register value */
-    u8               enable;
-    int              system_temp;    /*In unit of mini-Celsius*/
-    int              sensors_found;
-};
-
-enum fan_id {
-    FAN1_ID,
-    FAN2_ID,
-    FAN3_ID,
-    FAN4_ID,
-    FAN5_ID,
-    FAN6_ID
-};
-
-enum sysfs_fan_attributes {
-    FAN_PRESENT_REG,
-    FAN_DIRECTION_REG,
-    FAN_DUTY_CYCLE_PERCENTAGE, /* Only one CPLD register to control duty cycle for all fans */
-    FAN1_FRONT_SPEED_RPM,
-    FAN2_FRONT_SPEED_RPM,
-    FAN3_FRONT_SPEED_RPM,
-    FAN4_FRONT_SPEED_RPM,
-    FAN5_FRONT_SPEED_RPM,
-    FAN6_FRONT_SPEED_RPM,
-    FAN1_REAR_SPEED_RPM,
-    FAN2_REAR_SPEED_RPM,
-    FAN3_REAR_SPEED_RPM,
-    FAN4_REAR_SPEED_RPM,
-    FAN5_REAR_SPEED_RPM,
-    FAN6_REAR_SPEED_RPM,
-    FAN_WDT_TIMER,
-    FAN_WDT_MAX_PWM,
-    FAN_WDT_STATUS,
-    FAN1_DIRECTION,
-    FAN2_DIRECTION,
-    FAN3_DIRECTION,
-    FAN4_DIRECTION,
-    FAN5_DIRECTION,
-    FAN6_DIRECTION,
-    FAN1_PRESENT,
-    FAN2_PRESENT,
-    FAN3_PRESENT,
-    FAN4_PRESENT,
-    FAN5_PRESENT,
-    FAN6_PRESENT,
-    FAN1_FAULT,
-    FAN2_FAULT,
-    FAN3_FAULT,
-    FAN4_FAULT,
-    FAN5_FAULT,
-    FAN6_FAULT
-};
-
-/* Define attributes
- */
-#define DECLARE_FAN_FAULT_SENSOR_DEV_ATTR(index, index2) \
-    static SENSOR_DEVICE_ATTR(fan##index##_fault, S_IRUGO, fan_show_value, NULL, FAN##index##_FAULT);\
-    static SENSOR_DEVICE_ATTR(fan##index2##_fault, S_IRUGO, fan_show_value, NULL, FAN##index##_FAULT)
-#define DECLARE_FAN_FAULT_ATTR(index, index2)      &sensor_dev_attr_fan##index##_fault.dev_attr.attr, \
-                                           &sensor_dev_attr_fan##index2##_fault.dev_attr.attr
-
-#define DECLARE_FAN_DIRECTION_SENSOR_DEV_ATTR(index) \
-    static SENSOR_DEVICE_ATTR(fan##index##_direction, S_IRUGO, fan_show_value, NULL, FAN##index##_DIRECTION)
-#define DECLARE_FAN_DIRECTION_ATTR(index)  &sensor_dev_attr_fan##index##_direction.dev_attr.attr
-
-#define DECLARE_FAN_DUTY_CYCLE_SENSOR_DEV_ATTR(index) \
-    static SENSOR_DEVICE_ATTR(fan_duty_cycle_percentage, S_IWUSR | S_IRUGO, fan_show_value, set_duty_cycle, FAN_DUTY_CYCLE_PERCENTAGE);\
-    static SENSOR_DEVICE_ATTR(pwm##index, S_IWUSR | S_IRUGO, fan_show_value, set_duty_cycle, FAN_DUTY_CYCLE_PERCENTAGE);\
-    static SENSOR_DEVICE_ATTR(pwm##index##_enable, S_IWUSR | S_IRUGO, get_enable, set_enable, FAN_DUTY_CYCLE_PERCENTAGE)
-
-#define DECLARE_FAN_DUTY_CYCLE_ATTR(index) &sensor_dev_attr_fan_duty_cycle_percentage.dev_attr.attr, \
-                                           &sensor_dev_attr_pwm##index.dev_attr.attr, \
-                                           &sensor_dev_attr_pwm##index##_enable.dev_attr.attr
-
-#define DECLARE_FAN_SYSTEM_TEMP_SENSOR_DEV_ATTR() \
-    static SENSOR_DEVICE_ATTR(sys_temp, S_IRUGO, get_sys_temp, NULL, FAN_DUTY_CYCLE_PERCENTAGE)
-
-#define DECLARE_FAN_SYSTEM_TEMP_ATTR()  &sensor_dev_attr_sys_temp.dev_attr.attr
-
-
-#define DECLARE_FAN_PRESENT_SENSOR_DEV_ATTR(index) \
-    static SENSOR_DEVICE_ATTR(fan##index##_present, S_IRUGO, fan_show_value, NULL, FAN##index##_PRESENT)
-#define DECLARE_FAN_PRESENT_ATTR(index)      &sensor_dev_attr_fan##index##_present.dev_attr.attr
-
-#define DECLARE_FAN_SPEED_RPM_SENSOR_DEV_ATTR(index, index2) \
-    static SENSOR_DEVICE_ATTR(fan##index##_front_speed_rpm, S_IRUGO, fan_show_value, NULL, FAN##index##_FRONT_SPEED_RPM);\
-    static SENSOR_DEVICE_ATTR(fan##index##_rear_speed_rpm, S_IRUGO, fan_show_value, NULL, FAN##index##_REAR_SPEED_RPM);\
-    static SENSOR_DEVICE_ATTR(fan##index##_input, S_IRUGO, fan_show_value, NULL, FAN##index##_FRONT_SPEED_RPM);\
-    static SENSOR_DEVICE_ATTR(fan##index2##_input, S_IRUGO, fan_show_value, NULL, FAN##index##_REAR_SPEED_RPM)
-#define DECLARE_FAN_SPEED_RPM_ATTR(index, index2)  &sensor_dev_attr_fan##index##_front_speed_rpm.dev_attr.attr, \
-                                           &sensor_dev_attr_fan##index##_rear_speed_rpm.dev_attr.attr, \
-                                           &sensor_dev_attr_fan##index##_input.dev_attr.attr, \
-                                           &sensor_dev_attr_fan##index2##_input.dev_attr.attr
-
-#define DECLARE_FAN_WDT_SENSOR_DEV_ATTR() \
-    static SENSOR_DEVICE_ATTR(fan_wdt_timer, S_IWUSR | S_IRUGO, fan_show_value, set_wdt_timer, FAN_WDT_TIMER);\
-    static SENSOR_DEVICE_ATTR(fan_wdt_max_pwm, S_IWUSR | S_IRUGO, fan_show_value, set_wdt_max_pwm, FAN_WDT_MAX_PWM);\
-    static SENSOR_DEVICE_ATTR(fan_wdt_status, S_IWUSR | S_IRUGO, fan_show_value, set_wdt_status, FAN_WDT_STATUS)
-#define DECLARE_FAN_WDT_TIMER_ATTR() &sensor_dev_attr_fan_wdt_timer.dev_attr.attr
-#define DECLARE_FAN_WDT_MAX_PWM_ATTR() &sensor_dev_attr_fan_wdt_max_pwm.dev_attr.attr
-#define DECLARE_FAN_WDT_STATUS_ATTR() &sensor_dev_attr_fan_wdt_status.dev_attr.attr
-
-/* 6 fan fault attributes in this platform */
-DECLARE_FAN_FAULT_SENSOR_DEV_ATTR(1,11);
-DECLARE_FAN_FAULT_SENSOR_DEV_ATTR(2,12);
-DECLARE_FAN_FAULT_SENSOR_DEV_ATTR(3,13);
-DECLARE_FAN_FAULT_SENSOR_DEV_ATTR(4,14);
-DECLARE_FAN_FAULT_SENSOR_DEV_ATTR(5,15);
-DECLARE_FAN_FAULT_SENSOR_DEV_ATTR(6,16);
-/* 6 fan speed(rpm) attributes in this platform */
-DECLARE_FAN_SPEED_RPM_SENSOR_DEV_ATTR(1,11);
-DECLARE_FAN_SPEED_RPM_SENSOR_DEV_ATTR(2,12);
-DECLARE_FAN_SPEED_RPM_SENSOR_DEV_ATTR(3,13);
-DECLARE_FAN_SPEED_RPM_SENSOR_DEV_ATTR(4,14);
-DECLARE_FAN_SPEED_RPM_SENSOR_DEV_ATTR(5,15);
-DECLARE_FAN_SPEED_RPM_SENSOR_DEV_ATTR(6,16);
-/* 6 fan present attributes in this platform */
-DECLARE_FAN_PRESENT_SENSOR_DEV_ATTR(1);
-DECLARE_FAN_PRESENT_SENSOR_DEV_ATTR(2);
-DECLARE_FAN_PRESENT_SENSOR_DEV_ATTR(3);
-DECLARE_FAN_PRESENT_SENSOR_DEV_ATTR(4);
-DECLARE_FAN_PRESENT_SENSOR_DEV_ATTR(5);
-DECLARE_FAN_PRESENT_SENSOR_DEV_ATTR(6);
-/* 6 fan direction attribute in this platform */
-DECLARE_FAN_DIRECTION_SENSOR_DEV_ATTR(1);
-DECLARE_FAN_DIRECTION_SENSOR_DEV_ATTR(2);
-DECLARE_FAN_DIRECTION_SENSOR_DEV_ATTR(3);
-DECLARE_FAN_DIRECTION_SENSOR_DEV_ATTR(4);
-DECLARE_FAN_DIRECTION_SENSOR_DEV_ATTR(5);
-DECLARE_FAN_DIRECTION_SENSOR_DEV_ATTR(6);
-/* 1 fan duty cycle attribute in this platform */
-DECLARE_FAN_DUTY_CYCLE_SENSOR_DEV_ATTR(1);
-/* System temperature for fancontrol */
-DECLARE_FAN_SYSTEM_TEMP_SENSOR_DEV_ATTR();
-/* 3 fan wdt attribute in this platform  */
-DECLARE_FAN_WDT_SENSOR_DEV_ATTR();
-
-
-static struct attribute *as7326_56x_fan_attributes[] = {
-    /* fan related attributes */
-    DECLARE_FAN_FAULT_ATTR(1,11),
-    DECLARE_FAN_FAULT_ATTR(2,12),
-    DECLARE_FAN_FAULT_ATTR(3,13),
-    DECLARE_FAN_FAULT_ATTR(4,14),
-    DECLARE_FAN_FAULT_ATTR(5,15),
-    DECLARE_FAN_FAULT_ATTR(6,16),
-    DECLARE_FAN_SPEED_RPM_ATTR(1,11),
-    DECLARE_FAN_SPEED_RPM_ATTR(2,12),
-    DECLARE_FAN_SPEED_RPM_ATTR(3,13),
-    DECLARE_FAN_SPEED_RPM_ATTR(4,14),
-    DECLARE_FAN_SPEED_RPM_ATTR(5,15),
-    DECLARE_FAN_SPEED_RPM_ATTR(6,16),
-    DECLARE_FAN_PRESENT_ATTR(1),
-    DECLARE_FAN_PRESENT_ATTR(2),
-    DECLARE_FAN_PRESENT_ATTR(3),
-    DECLARE_FAN_PRESENT_ATTR(4),
-    DECLARE_FAN_PRESENT_ATTR(5),
-    DECLARE_FAN_PRESENT_ATTR(6),
-    DECLARE_FAN_DIRECTION_ATTR(1),
-    DECLARE_FAN_DIRECTION_ATTR(2),
-    DECLARE_FAN_DIRECTION_ATTR(3),
-    DECLARE_FAN_DIRECTION_ATTR(4),
-    DECLARE_FAN_DIRECTION_ATTR(5),
-    DECLARE_FAN_DIRECTION_ATTR(6),
-    DECLARE_FAN_DUTY_CYCLE_ATTR(1),
-    DECLARE_FAN_SYSTEM_TEMP_ATTR(),
-    DECLARE_FAN_WDT_TIMER_ATTR(),
-    DECLARE_FAN_WDT_MAX_PWM_ATTR(),
-    DECLARE_FAN_WDT_STATUS_ATTR(),
-    NULL
-};
-
-#define FAN_DUTY_CYCLE_REG_MASK         0xF
-#define FAN_MAX_DUTY_CYCLE              100
-#define FAN_REG_VAL_TO_SPEED_RPM_STEP   100
-
-static int as7326_56x_fan_read_value(struct i2c_client *client, u8 reg)
-{
-    return i2c_smbus_read_byte_data(client, reg);
-}
-
-static int as7326_56x_fan_write_value(struct i2c_client *client, u8 reg, u8 value)
-{
-    return i2c_smbus_write_byte_data(client, reg, value);
-}
-
-/* fan utility functions
- */
-static u32 reg_val_to_duty_cycle(u8 reg_val)
-{
-    reg_val &= FAN_DUTY_CYCLE_REG_MASK;
-    return ((u32)(reg_val+1) * 625 + 75)/ 100;
-}
-
-static u8 duty_cycle_to_reg_val(u8 duty_cycle)
-{
-    return ((u32)duty_cycle * 100 / 625) - 1;
-}
-
-static u32 reg_val_to_speed_rpm(u8 reg_val)
-{
-    return (u32)reg_val * FAN_REG_VAL_TO_SPEED_RPM_STEP;
-}
-
-static u8 reg_val_to_direction(u8 reg_val, enum fan_id id)
-{
-	u8 mask = (1 << id);
-
-	reg_val &= mask;
-
-	return reg_val ? 1 : 0;
-}
-static u8 reg_val_to_is_present(u8 reg_val, enum fan_id id)
-{
-    u8 mask = (1 << id);
-
-    reg_val &= mask;
-
-    return reg_val ? 0 : 1;
-}
-
-static u8 is_fan_fault(struct as7326_56x_fan_data *data, enum fan_id id)
-{
-    u8 ret = 1;
-    int front_fan_index = FAN1_FRONT_SPEED_RPM + id;
-    int rear_fan_index  = FAN1_REAR_SPEED_RPM  + id;
-
-    /* Check if the speed of front or rear fan is ZERO,
-     */
-    if (reg_val_to_speed_rpm(data->reg_val[front_fan_index]) &&
-            reg_val_to_speed_rpm(data->reg_val[rear_fan_index]))  {
-        ret = 0;
-    }
-
-    return ret;
-}
-
-static ssize_t set_enable(struct device *dev, struct device_attribute *da,
-                          const char *buf, size_t count)
-{
-    struct i2c_client *client = to_i2c_client(dev);
-    struct as7326_56x_fan_data *data = i2c_get_clientdata(client);
-    int error, value;
-
-    error = kstrtoint(buf, 10, &value);
-    if (error)
-        return error;
-
-    if (value < 0 || value > 1)
-        return -EINVAL;
-
-    mutex_lock(&data->update_lock);
-    data = as7326_56x_fan_update_device(dev);
-
-    data->enable = value;
-    if (value == 0)
-    {
-        mutex_unlock(&data->update_lock);
-        return set_duty_cycle(dev, da, buf, FAN_MAX_DUTY_CYCLE);
-    }
-
-    mutex_unlock(&data->update_lock);
-    return count;
-}
-
-
-static ssize_t get_enable(struct device *dev, struct device_attribute *da,
-                          char *buf)
-{
-    u8 enable = 0;
-    struct i2c_client *client = to_i2c_client(dev);
-    struct as7326_56x_fan_data *data = i2c_get_clientdata(client);
-
-    mutex_lock(&data->update_lock);
-
-    data = as7326_56x_fan_update_device(dev);
-    enable = data->enable;
-
-    mutex_unlock(&data->update_lock);
-
-    return sprintf(buf, "%u\n", data->enable);
-}
-static ssize_t set_duty_cycle(struct device *dev, struct device_attribute *da,
-                              const char *buf, size_t count)
-{
-    int error, value;
-    struct i2c_client *client = to_i2c_client(dev);
-
-    error = kstrtoint(buf, 10, &value);
-    if (error)
-        return error;
-
-    if (value < 0)
-        return -EINVAL;
-
-    value = (value > FAN_MAX_DUTY_CYCLE)? FAN_MAX_DUTY_CYCLE : value;
-
-    as7326_56x_fan_write_value(client, 0x33, 0); /* Disable fan speed watch dog */
-    as7326_56x_fan_write_value(client, fan_reg[FAN_DUTY_CYCLE_PERCENTAGE], duty_cycle_to_reg_val(value));
-    return count;
-}
-
-/* Due to this struct is declared at lm75.c, it cannot be include
- * under Sonic environment. I duplicate it from lm75.c.
- */
-struct lm75_data {
-    struct i2c_client       *client;
-    struct device           *hwmon_dev;
-    struct thermal_zone_device      *tz;
-    struct mutex            update_lock;
-    u8                      orig_conf;
-    u8                      resolution;     /* In bits, between 9 and 12 */
-    u8                      resolution_limits;
-    char                    valid;          /* !=0 if registers are valid */
-    unsigned long           last_updated;   /* In jiffies */
-    unsigned long           sample_time;    /* In jiffies */
-    s16                     temp[3];        /* Register values,
-                                                   0 = input
-                                                   1 = max
-                                                   2 = hyst */
-};
-
-/*Copied from lm75.c*/
-static inline long lm75_reg_to_mc(s16 temp, u8 resolution)
-{
-    return ((temp >> (16 - resolution)) * 1000) >> (resolution - 8);
-}
-
-/*Get hwmon_dev from i2c_client, set hwmon_dev = NULL is failed.*/
-static struct device * get_hwmon_dev(
-    struct i2c_client *client)
-{
-    struct lm75_data *data = NULL;
-
-    data = i2c_get_clientdata(client);
-    if(data)
-    {
-        if( data->valid == 1  && data->hwmon_dev)
-        {
-            return data->hwmon_dev;
-        }
-
-    }
-    return NULL;
-}
-
-/* To find hwmon index by opening hwmon under that i2c address.
- */
-static int find_hwmon_index_by_FileOpen(
-    int bus_nr,
-    unsigned short addr,
-    OUT int *index)
-{
-#define MAX_HWMON_DEVICE        (10)    /* Find hwmon device in 0~10*/
-    struct file *sfd;
-    char client_name[96];
-    int  i=0;
-
-    do {
-        snprintf(client_name, sizeof(client_name),
-                 "/sys/bus/i2c/devices/%d-%04x/hwmon/hwmon%d/temp1_input",
-                 bus_nr, addr, i);
-
-        sfd = filp_open(client_name, O_RDONLY, 0);
-        i++;
-    } while( IS_ERR(sfd) && i < MAX_HWMON_DEVICE);
-
-    if (IS_ERR(sfd)) {
-        pr_err("Failed to open file(%s)#%d\r\n", client_name, __LINE__);
-        return -ENOENT;
-    }
-    filp_close(sfd, 0);
-    *index = i - 1;
-    return 0;
-
-#undef MAX_HWMON_DEVICE
-}
-
-static int get_temp_file_path(
-    int bus_nr, unsigned short addr,
-    struct device *hwmon_dev
-    ,char *path, int max_len)
-{
-
-    if(hwmon_dev && strlen(dev_name(hwmon_dev)))
-    {
-        snprintf(path, max_len,
-                 "/sys/bus/i2c/devices/%d-%04x/hwmon/%s/temp1_input",
-                 bus_nr, addr, dev_name(hwmon_dev));
-    }
-    else
-    {
-        int  i=0;
-        if(find_hwmon_index_by_FileOpen( bus_nr, addr, &i))
-        {
-            return  -EIO;
-        }
-        snprintf(path, max_len,
-                 "/sys/bus/i2c/devices/%d-%04x/hwmon/hwmon%d/temp1_input",
-                 bus_nr, addr, i);
-    }
-    return 0;
-}
-
-/*File read the dev file at user space.*/
-static int read_devfile_temp1_input(
-    struct device *dev,
-    int bus_nr,
-    unsigned short addr,
-    struct device *hwmon_dev,
-    int *miniCelsius)
-{
-    struct file *sfd;
-    char buffer[96];
-    char devfile[96];
-    int     rc, status;
-    int     rdlen, value;
-    mm_segment_t old_fs;
-
-    rc = 0;
-    get_temp_file_path(bus_nr, addr, hwmon_dev, devfile, sizeof(devfile));
-    sfd = filp_open(devfile, O_RDONLY, 0);
-    if (IS_ERR(sfd)) {
-        pr_err("Failed to open file(%s)#%d\r\n", devfile, __LINE__);
-        return -ENOENT;
-    }
-    dev_dbg(dev, "Found device:%s\n",devfile);
-
-    if(!(sfd->f_op) || !(sfd->f_op->read) ) {
-        pr_err("file %s cann't readable ?\n",devfile);
-        return -ENOENT;
-    }
-
-    old_fs = get_fs();
-    set_fs(KERNEL_DS);
-    rdlen = sfd->f_op->read(sfd, buffer, sizeof(buffer), &sfd->f_pos);
-    if (rdlen == 0) {
-        pr_err( "File(%s) empty!\n", devfile);
-        rc = -EIO;
-        goto exit;
-    }
-    status = sscanf(buffer, "%d", &value);
-    if (status != 1) {
-        rc = -EIO;
-        goto exit;
-    }
-    *miniCelsius = value;
-    dev_dbg(dev,"found sensors: %d @i2c %d-%04x\n", value, bus_nr, addr);
-
-exit:
-    set_fs(old_fs);
-    filp_close(sfd, 0);
-    return rc;
-}
-
-static u8 is_lm75_data_due(struct i2c_client *client)
-{
-    struct lm75_data *data = NULL;
-
-    data = i2c_get_clientdata(client);
-    if (time_after(jiffies, data->last_updated + data->sample_time))
-    {
-        return 1;
-    }
-    return 0;
-}
-static int get_lm75_temp(struct i2c_client *client, int *miniCelsius)
-{
-    struct lm75_data *data = NULL;
-
-    data = i2c_get_clientdata(client);
-    *miniCelsius = lm75_reg_to_mc(data->temp[0], data->resolution);
-
-    return 0;
-}
-
-static bool lm75_addr_mached(unsigned short addr)
-{
-    int i;
-    unsigned short addrs[] = THERMAL_SENSORS_ADDRS;
-
-    for (i = 0; i < ARRAY_SIZE(addrs); i++)
-    {
-        if( addr == addrs[i])
-            return 1;
-    }
-    return 0;
-}
-
-static int _find_lm75_device(struct device *dev, void *data)
-{
-    struct device_driver *driver;
-    struct as7326_56x_fan_data *prv = data;
-    char *driver_name = THERMAL_SENSORS_DRIVER;
-
-    driver = dev->driver;
-    if (driver && driver->name &&
-            strcmp(driver->name, driver_name) == 0)
-    {
-        struct i2c_client *client;
-        client = to_i2c_client(dev);
-        if (client)
-        {
-            /*cannot use "struct i2c_adapter *adap = to_i2c_adapter(dev);"*/
-            struct i2c_adapter *adap = client->adapter;
-            int miniCelsius = 0;
-
-            if (! lm75_addr_mached(client->addr))
-            {
-                return 0;
-            }
-
-            if (!adap) {
-                return -ENXIO;
-            }
-
-            /* If the data is not updated, read them from devfile
-               to drive them updateing data from chip.*/
-            if (is_lm75_data_due(client))
-            {
-                struct device *hwmon_dev;
-
-                hwmon_dev = get_hwmon_dev(client);
-                if(0 == read_devfile_temp1_input(dev, adap->nr,
-                                                 client->addr, hwmon_dev, &miniCelsius))
-                {
-                    prv->system_temp += miniCelsius;
-                    prv->sensors_found++;
-                }
-
-            }
-            else
-            {
-                get_lm75_temp(client, &miniCelsius);
-                prv->system_temp += miniCelsius;
-                prv->sensors_found++;
-
-            }
-        }
-    }
-    return 0;
-}
-
-/*Find all lm75 devices and return sum of temperatures.*/
-static ssize_t get_sys_temp(struct device *dev, struct device_attribute *da,
-                            char *buf)
-{
-    ssize_t ret = 0;
-    struct i2c_client *client = to_i2c_client(dev);
-    struct as7326_56x_fan_data *data = i2c_get_clientdata(client);
-
-    mutex_lock(&data->update_lock);
-    data = as7326_56x_fan_update_device(dev);
-
-    data->system_temp=0;
-    data->sensors_found=0;
-    i2c_for_each_dev(data, _find_lm75_device);
-    if (NUM_THERMAL_SENSORS != data->sensors_found)
-    {
-        dev_dbg(dev,"only %d of %d temps are found\n",
-                data->sensors_found, NUM_THERMAL_SENSORS);
-        data->system_temp = INT_MAX;
-    }
-    ret = sprintf(buf, "%d\n",data->system_temp);
-    mutex_unlock(&data->update_lock);
-    return ret;
-}
-
-static ssize_t set_wdt_status(struct device *dev, struct device_attribute *da,
-                              const char *buf, size_t count)
-{
-    int error, value;
-    struct i2c_client *client = to_i2c_client(dev);
-    struct as7326_56x_fan_data *data = i2c_get_clientdata(client);
-    int reg = 0x33;
-
-    error = kstrtoint(buf, 10, &value);
-    if (error) {
-        return error;
-    }
-
-    if (value < 0 || value > 1) {
-        return -EINVAL;
-    }
-
-    mutex_lock(&data->update_lock);
-
-    /* Enable or Disable the watchdog */
-    error = as7326_56x_fan_write_value(client, reg, value);
-
-    if (error != 0) {
-        dev_dbg(&client->dev, "Unable to enable/disable the watchdog\n");
-        mutex_unlock(&data->update_lock);
-        return error;
-    }
-
-    mutex_unlock(&data->update_lock);
-
-    return count;
-}
-
-static ssize_t set_wdt_timer(struct device *dev, struct device_attribute *da,
-                              const char *buf, size_t count)
-{
-    int error, value;
-    struct i2c_client *client = to_i2c_client(dev);
-    struct as7326_56x_fan_data *data = i2c_get_clientdata(client);
-    int reg = 0x31;
-
-    error = kstrtoint(buf, 10, &value);
-    if (error) {
-        return error;
-    }
-
-    if (value < 0 || value > 255) {
-        return -EINVAL;
-    }
-
-    mutex_lock(&data->update_lock);
-
-    /* set the watchdog timer */
-    error = as7326_56x_fan_write_value(client, reg, value);
-
-    if (error != 0) {
-        dev_dbg(&client->dev, "Unable to set time to watchdog timer\n");
-        mutex_unlock(&data->update_lock);
-        return error;
-    }
-
-    mutex_unlock(&data->update_lock);
-
-    return count;
-}
-
-static ssize_t set_wdt_max_pwm(struct device *dev, struct device_attribute *da,
-                              const char *buf, size_t count)
-{
-    int error, value;
-    struct i2c_client *client = to_i2c_client(dev);
-    struct as7326_56x_fan_data *data = i2c_get_clientdata(client);
-    int reg = 0x32;
-
-    error = kstrtoint(buf, 10, &value);
-    if (error) {
-        return error;
-    }
-
-    if (value < 0 || value > 15) {
-        return -EINVAL;
-    }
-
-    mutex_lock(&data->update_lock);
-
-    /* set the watchdog timer */
-    error = as7326_56x_fan_write_value(client, reg, value);
-
-    if (error != 0) {
-        dev_dbg(&client->dev, "Unable to set time to watchdog timer\n");
-        mutex_unlock(&data->update_lock);
-        return error;
-    }
-
-    mutex_unlock(&data->update_lock);
-
-    return count;
-}
-
-static ssize_t fan_show_value(struct device *dev, struct device_attribute *da,
-                              char *buf)
-{
-    struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
-    struct i2c_client *client = to_i2c_client(dev);
-    struct as7326_56x_fan_data *data = i2c_get_clientdata(client);
-    ssize_t ret = 0;
-
-    mutex_lock(&data->update_lock);
-    data = as7326_56x_fan_update_device(dev);
-
-    if (data->valid) {
-        switch (attr->index) {
-        case FAN_DUTY_CYCLE_PERCENTAGE:
-        {
-            u32 duty_cycle = reg_val_to_duty_cycle(data->reg_val[FAN_DUTY_CYCLE_PERCENTAGE]);
-            ret = sprintf(buf, "%u\n", duty_cycle);
-            break;
-        }
-        case FAN1_FRONT_SPEED_RPM:
-        case FAN2_FRONT_SPEED_RPM:
-        case FAN3_FRONT_SPEED_RPM:
-        case FAN4_FRONT_SPEED_RPM:
-        case FAN5_FRONT_SPEED_RPM:
-        case FAN6_FRONT_SPEED_RPM:
-        case FAN1_REAR_SPEED_RPM:
-        case FAN2_REAR_SPEED_RPM:
-        case FAN3_REAR_SPEED_RPM:
-        case FAN4_REAR_SPEED_RPM:
-        case FAN5_REAR_SPEED_RPM:
-        case FAN6_REAR_SPEED_RPM:
-            ret = sprintf(buf, "%u\n", reg_val_to_speed_rpm(data->reg_val[attr->index]));
-            break;
-        case FAN1_PRESENT:
-        case FAN2_PRESENT:
-        case FAN3_PRESENT:
-        case FAN4_PRESENT:
-        case FAN5_PRESENT:
-        case FAN6_PRESENT:
-            ret = sprintf(buf, "%d\n",
-                          reg_val_to_is_present(data->reg_val[FAN_PRESENT_REG],
-                                                attr->index - FAN1_PRESENT));
-            break;
-        case FAN1_FAULT:
-        case FAN2_FAULT:
-        case FAN3_FAULT:
-        case FAN4_FAULT:
-        case FAN5_FAULT:
-        case FAN6_FAULT:
-            ret = sprintf(buf, "%d\n", is_fan_fault(data, attr->index - FAN1_FAULT));
-            break;
-        case FAN1_DIRECTION:
-        case FAN2_DIRECTION:
-        case FAN3_DIRECTION:
-        case FAN4_DIRECTION:
-        case FAN5_DIRECTION:
-        case FAN6_DIRECTION:
-            ret = sprintf(buf, "%d\n",
-                          reg_val_to_direction(data->reg_val[FAN_DIRECTION_REG],
-                                               attr->index - FAN1_DIRECTION));
-            break;
-        case FAN_WDT_TIMER:
-        case FAN_WDT_MAX_PWM:
-        case FAN_WDT_STATUS:
-            ret = sprintf(buf, "%u\n", data->reg_val[attr->index]);
-            break;
-        default:
-            break;
-        }
-    }
-
-    mutex_unlock(&data->update_lock);
-    return ret;
-}
-
-static const struct attribute_group as7326_56x_fan_group = {
-    .attrs = as7326_56x_fan_attributes,
-};
-
-static struct as7326_56x_fan_data *as7326_56x_fan_update_device(struct device *dev)
-{
-    struct i2c_client *client = to_i2c_client(dev);
-    struct as7326_56x_fan_data *data = i2c_get_clientdata(client);
-
-    if (time_after(jiffies, data->last_updated + HZ + HZ / 2) ||
-            !data->valid) {
-        int i;
-
-        dev_dbg(&client->dev, "Starting as7326_56x_fan update\n");
-        data->valid = 0;
-
-        /* Update fan data
-         */
-        for (i = 0; i < ARRAY_SIZE(data->reg_val); i++) {
-            int status = as7326_56x_fan_read_value(client, fan_reg[i]);
-
-            if (status < 0) {
-                data->valid = 0;
-                dev_dbg(&client->dev, "reg %d, err %d\n", fan_reg[i], status);
-                return data;
-            }
-            else {
-                data->reg_val[i] = status;
-            }
-        }
-
-        data->last_updated = jiffies;
-        data->valid = 1;
-    }
-
-    return data;
-}
-
-static int as7326_56x_fan_probe(struct i2c_client *client,
-                                const struct i2c_device_id *dev_id)
-{
-    struct as7326_56x_fan_data *data;
-    int status;
-
-    if (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {
-        status = -EIO;
-        goto exit;
-    }
-
-    data = kzalloc(sizeof(struct as7326_56x_fan_data), GFP_KERNEL);
-    if (!data) {
-        status = -ENOMEM;
-        goto exit;
-    }
-
-    i2c_set_clientdata(client, data);
-    data->valid = 0;
-    data->enable = 0;
-    mutex_init(&data->update_lock);
-
-    dev_info(&client->dev, "chip found\n");
-
-    /* Register sysfs hooks */
-    status = sysfs_create_group(&client->dev.kobj, &as7326_56x_fan_group);
-    if (status) {
-        goto exit_free;
-    }
-
-    data->hwmon_dev = hwmon_device_register_with_info(&client->dev, "as7326_56x_fan",
-                                                      NULL, NULL, NULL);
-    if (IS_ERR(data->hwmon_dev)) {
-        status = PTR_ERR(data->hwmon_dev);
-        goto exit_remove;
-    }
-
-    dev_info(&client->dev, "%s: fan '%s'\n",
-             dev_name(data->hwmon_dev), client->name);
-
-    return 0;
-
-exit_remove:
-    sysfs_remove_group(&client->dev.kobj, &as7326_56x_fan_group);
-exit_free:
-    kfree(data);
-exit:
-
-    return status;
-}
-
-static int as7326_56x_fan_remove(struct i2c_client *client)
-{
-    struct as7326_56x_fan_data *data = i2c_get_clientdata(client);
-    hwmon_device_unregister(data->hwmon_dev);
-    sysfs_remove_group(&client->dev.kobj, &as7326_56x_fan_group);
-
-    return 0;
-}
-
-/* Addresses to scan */
-static const unsigned short normal_i2c[] = { 0x66, I2C_CLIENT_END };
-
-static const struct i2c_device_id as7326_56x_fan_id[] = {
-    { "as7326_56x_fan", 0 },
-    {}
-};
-MODULE_DEVICE_TABLE(i2c, as7326_56x_fan_id);
-
-static struct i2c_driver as7326_56x_fan_driver = {
-    .class        = I2C_CLASS_HWMON,
-    .driver = {
-        .name     = DRVNAME,
-    },
-    .probe        = as7326_56x_fan_probe,
-    .remove       = as7326_56x_fan_remove,
-    .id_table     = as7326_56x_fan_id,
-    .address_list = normal_i2c,
-};
-
-static int __init as7326_56x_fan_init(void)
-{
-    return i2c_add_driver(&as7326_56x_fan_driver);
-}
-
-static void __exit as7326_56x_fan_exit(void)
-{
-    i2c_del_driver(&as7326_56x_fan_driver);
-}
-
-module_init(as7326_56x_fan_init);
-module_exit(as7326_56x_fan_exit);
-
-MODULE_AUTHOR("Brandon Chuang <brandon_chuang@accton.com.tw>");
-MODULE_DESCRIPTION("as7326_56x_fan driver");
-MODULE_LICENSE("GPL");
-
diff --git a/packages/platforms/accton/x86-64/as7326-56x/modules/builds/x86-64-accton-as7326-56x-leds.c b/packages/platforms/accton/x86-64/as7326-56x/modules/builds/x86-64-accton-as7326-56x-leds.c
deleted file mode 100644
index 8484531b..00000000
--- a/packages/platforms/accton/x86-64/as7326-56x/modules/builds/x86-64-accton-as7326-56x-leds.c
+++ /dev/null
@@ -1,455 +0,0 @@
-/*
- * A LED driver for the accton_as7326_56x_led
- *
- * Copyright (C) 2014 Accton Technology Corporation.
- * Brandon Chuang <brandon_chuang@accton.com.tw>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
-
-/*#define DEBUG*/
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/err.h>
-#include <linux/leds.h>
-#include <linux/slab.h>
-#include <linux/dmi.h>
-
-extern int as7326_56x_cpld_read (unsigned short cpld_addr, u8 reg);
-extern int as7326_56x_cpld_write(unsigned short cpld_addr, u8 reg, u8 value);
-
-#define DRVNAME "accton_as7326_56x_led"
-
-struct accton_as7326_56x_led_data {
-    struct platform_device *pdev;
-    struct mutex	 update_lock;
-    char			 valid;		   /* != 0 if registers are valid */
-    unsigned long	last_updated;	/* In jiffies */
-    u8			   reg_val[2];
-};
-
-static struct accton_as7326_56x_led_data  *ledctl = NULL;
-
-/* LED related data
- */
-
-/* LED has only red, green and blue.
- * Amber  =  red + green.
- * Purple =  red + blue.
- */
-
-#define LED_CNTRLER_I2C_ADDRESS	(0x60)
-
-#define LED_TYPE_DIAG_REG_MASK          (0x3F)
-#define LED_MODE_DIAG_OFF_VALUE         (0x07)
-#define LED_TYPE_LOC_REG_MASK           (0x3F)
-#define LED_MODE_LOC_OFF_VALUE          (0x07)
-
-enum led_type {
-    LED_TYPE_DIAG,
-    LED_TYPE_LOC,
-    LED_TYPE_FAN,
-    LED_TYPE_PSU1,
-    LED_TYPE_PSU2
-};
-
-struct led_reg {
-    u32  types;
-    u8   reg_addr;
-};
-
-static const struct led_reg led_reg_map[] = {
-    {(1<<LED_TYPE_DIAG), 0x24},
-    {(1<<LED_TYPE_LOC) , 0x25},
-};
-
-
-enum led_light_mode {
-    LED_MODE_OFF = 0,
-    LED_MODE_RED,
-    LED_MODE_GREEN,
-    LED_MODE_BLUE,
-    LED_MODE_AMBER,
-    LED_MODE_PURPLE,
-    LED_MODE_RED_BLINK,
-    LED_MODE_GREEN_BLINK,
-    LED_MODE_BLUE_BLINK,
-    LED_MODE_AMBER_BLINK,
-    LED_MODE_PURPLE_BLINK,
-    LED_MODE_AUTO,
-    LED_MODE_UNKNOWN
-};
-
-struct led_type_mode {
-    enum led_type type;
-    enum led_light_mode mode;
-    int  reg_bit_mask;
-    int  mode_value;
-    int  mode_value_blinking;
-};
-
-static struct led_type_mode led_type_mode_data[] = {
-    {LED_TYPE_DIAG,  LED_MODE_OFF,	        LED_TYPE_DIAG_REG_MASK,   LED_MODE_DIAG_OFF_VALUE},
-    {LED_TYPE_DIAG,  LED_MODE_RED,	        LED_TYPE_DIAG_REG_MASK,   0x06,   0x06},
-    {LED_TYPE_DIAG,  LED_MODE_GREEN,	    LED_TYPE_DIAG_REG_MASK,   0x05,   0x05},
-    {LED_TYPE_DIAG,  LED_MODE_BLUE,	        LED_TYPE_DIAG_REG_MASK,   0x03,   0x03},
-    {LED_TYPE_DIAG,  LED_MODE_AMBER,	    LED_TYPE_DIAG_REG_MASK,   0x04,   0x04},
-    {LED_TYPE_DIAG,  LED_MODE_PURPLE,       LED_TYPE_DIAG_REG_MASK,   0x02,   0x02},
-    {LED_TYPE_DIAG,  LED_MODE_RED_BLINK,	LED_TYPE_DIAG_REG_MASK,   0x0f,   0x0e},
-    {LED_TYPE_DIAG,  LED_MODE_GREEN_BLINK,	LED_TYPE_DIAG_REG_MASK,   0x17,   0x15},
-    {LED_TYPE_DIAG,  LED_MODE_BLUE_BLINK,	LED_TYPE_DIAG_REG_MASK,   0x27,   0x23},
-    {LED_TYPE_DIAG,  LED_MODE_AMBER_BLINK,	LED_TYPE_DIAG_REG_MASK,   0x1f,   0x1c},
-    {LED_TYPE_DIAG,  LED_MODE_PURPLE_BLINK,	LED_TYPE_DIAG_REG_MASK,   0x2f,   0x2a},
-
-    {LED_TYPE_LOC,  LED_MODE_OFF,	        LED_TYPE_LOC_REG_MASK,   LED_MODE_LOC_OFF_VALUE},
-    {LED_TYPE_LOC,  LED_MODE_RED,	        LED_TYPE_LOC_REG_MASK,   0x06,   0x06},
-    {LED_TYPE_LOC,  LED_MODE_GREEN,	        LED_TYPE_LOC_REG_MASK,   0x05,   0x05},
-    {LED_TYPE_LOC,  LED_MODE_BLUE,	        LED_TYPE_LOC_REG_MASK,   0x03,   0x03},
-    {LED_TYPE_LOC,  LED_MODE_AMBER,	        LED_TYPE_LOC_REG_MASK,   0x04,   0x04},
-    {LED_TYPE_LOC,  LED_MODE_PURPLE,        LED_TYPE_LOC_REG_MASK,   0x02,   0x02},
-    {LED_TYPE_LOC,  LED_MODE_RED_BLINK,	    LED_TYPE_LOC_REG_MASK,   0x0f,   0x0e},
-    {LED_TYPE_LOC,  LED_MODE_GREEN_BLINK,	LED_TYPE_LOC_REG_MASK,   0x17,   0x15},
-    {LED_TYPE_LOC,  LED_MODE_BLUE_BLINK,	LED_TYPE_LOC_REG_MASK,   0x27,   0x23},
-    {LED_TYPE_LOC,  LED_MODE_AMBER_BLINK,	LED_TYPE_LOC_REG_MASK,   0x1f,   0x1c},
-    {LED_TYPE_LOC,  LED_MODE_PURPLE_BLINK,	LED_TYPE_LOC_REG_MASK,   0x2f,   0x2a},
-};
-
-
-
-static void accton_as7326_56x_led_set(struct led_classdev *led_cdev,
-                                      enum led_brightness led_light_mode, enum led_type type);
-
-
-
-
-
-static int accton_getLedReg(enum led_type type, u8 *reg)
-{
-    int i;
-    for (i = 0; i < ARRAY_SIZE(led_reg_map); i++) {
-        if(led_reg_map[i].types & (1 << type)) {
-            *reg = led_reg_map[i].reg_addr;
-            return 0;
-        }
-    }
-    return 1;
-}
-
-
-static int led_reg_val_to_light_mode(enum led_type type, u8 reg_val) {
-    int i;
-
-    for (i = 0; i < ARRAY_SIZE(led_type_mode_data); i++) {
-        if (type != led_type_mode_data[i].type)
-        {
-            continue;
-        }
-
-        if (((led_type_mode_data[i].reg_bit_mask & reg_val) == led_type_mode_data[i].mode_value)
-            || ((led_type_mode_data[i].reg_bit_mask & reg_val) == led_type_mode_data[i].mode_value_blinking))
-        {
-            return led_type_mode_data[i].mode;
-        }
-    }
-
-    return 0;
-}
-
-static u8 led_light_mode_to_reg_val(enum led_type type,
-                                    enum led_light_mode mode, u8 reg_val) {
-    int i;
-
-    for (i = 0; i < ARRAY_SIZE(led_type_mode_data); i++) {
-        if (type != led_type_mode_data[i].type)
-            continue;
-
-        if (mode != led_type_mode_data[i].mode)
-            continue;
-
-        reg_val = led_type_mode_data[i].mode_value |
-                  (reg_val & (~led_type_mode_data[i].reg_bit_mask));
-        break;
-    }
-
-    return reg_val;
-}
-
-static int accton_as7326_56x_led_read_value(u8 reg)
-{
-    return as7326_56x_cpld_read(LED_CNTRLER_I2C_ADDRESS, reg);
-}
-
-static int accton_as7326_56x_led_write_value(u8 reg, u8 value)
-{
-    return as7326_56x_cpld_write(LED_CNTRLER_I2C_ADDRESS, reg, value);
-}
-
-static void accton_as7326_56x_led_update(void)
-{
-    mutex_lock(&ledctl->update_lock);
-
-    if (time_after(jiffies, ledctl->last_updated + HZ + HZ / 2)
-            || !ledctl->valid) {
-        int i;
-
-        dev_dbg(&ledctl->pdev->dev, "Starting accton_as7326_56x_led update\n");
-
-        /* Update LED data
-         */
-        for (i = 0; i < ARRAY_SIZE(ledctl->reg_val); i++) {
-            int status = accton_as7326_56x_led_read_value(led_reg_map[i].reg_addr);
-
-            if (status < 0) {
-                ledctl->valid = 0;
-                dev_dbg(&ledctl->pdev->dev, "reg %d, err %d\n", led_reg_map[i].reg_addr, status);
-                goto exit;
-            }
-            else
-            {
-                ledctl->reg_val[i] = status;
-            }
-        }
-
-        ledctl->last_updated = jiffies;
-        ledctl->valid = 1;
-    }
-
-exit:
-    mutex_unlock(&ledctl->update_lock);
-}
-
-static void accton_as7326_56x_led_set(struct led_classdev *led_cdev,
-                                      enum led_brightness led_light_mode,
-                                      enum led_type type)
-{
-    int reg_val;
-    u8 reg	;
-
-    mutex_lock(&ledctl->update_lock);
-
-    if( !accton_getLedReg(type, &reg))
-    {
-        dev_dbg(&ledctl->pdev->dev, "Not match item for %d.\n", type);
-    }
-
-    reg_val = accton_as7326_56x_led_read_value(reg);
-
-    if (reg_val < 0) {
-        dev_dbg(&ledctl->pdev->dev, "reg %d, err %d\n", reg, reg_val);
-        goto exit;
-    }
-    reg_val = led_light_mode_to_reg_val(type, led_light_mode, reg_val);
-    accton_as7326_56x_led_write_value(reg, reg_val);
-
-    /* to prevent the slow-update issue */
-    ledctl->valid = 0;
-
-exit:
-    mutex_unlock(&ledctl->update_lock);
-}
-
-
-static void accton_as7326_56x_led_diag_set(struct led_classdev *led_cdev,
-        enum led_brightness led_light_mode)
-{
-    accton_as7326_56x_led_set(led_cdev, led_light_mode,  LED_TYPE_DIAG);
-}
-
-static enum led_brightness accton_as7326_56x_led_diag_get(struct led_classdev *cdev)
-{
-    accton_as7326_56x_led_update();
-    return led_reg_val_to_light_mode(LED_TYPE_DIAG, ledctl->reg_val[0]);
-}
-
-static void accton_as7326_56x_led_loc_set(struct led_classdev *led_cdev,
-        enum led_brightness led_light_mode)
-{
-    accton_as7326_56x_led_set(led_cdev, led_light_mode, LED_TYPE_LOC);
-}
-
-static enum led_brightness accton_as7326_56x_led_loc_get(struct led_classdev *cdev)
-{
-    accton_as7326_56x_led_update();
-    return led_reg_val_to_light_mode(LED_TYPE_LOC, ledctl->reg_val[1]);
-}
-
-static void accton_as7326_56x_led_auto_set(struct led_classdev *led_cdev,
-        enum led_brightness led_light_mode)
-{
-}
-
-static enum led_brightness accton_as7326_56x_led_auto_get(struct led_classdev *cdev)
-{
-    return LED_MODE_AUTO;
-}
-
-static struct led_classdev accton_as7326_56x_leds[] = {
-    [LED_TYPE_DIAG] = {
-        .name			 = "accton_as7326_56x_led::diag",
-        .default_trigger = "unused",
-        .brightness_set	 = accton_as7326_56x_led_diag_set,
-        .brightness_get	 = accton_as7326_56x_led_diag_get,
-        .flags			 = LED_CORE_SUSPENDRESUME,
-        .max_brightness	 = LED_MODE_PURPLE_BLINK,
-    },
-    [LED_TYPE_LOC] = {
-        .name			 = "accton_as7326_56x_led::loc",
-        .default_trigger = "unused",
-        .brightness_set	 = accton_as7326_56x_led_loc_set,
-        .brightness_get	 = accton_as7326_56x_led_loc_get,
-        .flags			 = LED_CORE_SUSPENDRESUME,
-        .max_brightness	 = LED_MODE_PURPLE_BLINK,
-    },
-    [LED_TYPE_FAN] = {
-        .name			 = "accton_as7326_56x_led::fan",
-        .default_trigger = "unused",
-        .brightness_set	 = accton_as7326_56x_led_auto_set,
-        .brightness_get  = accton_as7326_56x_led_auto_get,
-        .flags			 = LED_CORE_SUSPENDRESUME,
-        .max_brightness  = LED_MODE_AUTO,
-    },
-    [LED_TYPE_PSU1] = {
-        .name			 = "accton_as7326_56x_led::psu1",
-        .default_trigger = "unused",
-        .brightness_set	 = accton_as7326_56x_led_auto_set,
-        .brightness_get  = accton_as7326_56x_led_auto_get,
-        .flags			 = LED_CORE_SUSPENDRESUME,
-        .max_brightness  = LED_MODE_AUTO,
-    },
-    [LED_TYPE_PSU2] = {
-        .name			 = "accton_as7326_56x_led::psu2",
-        .default_trigger = "unused",
-        .brightness_set	 = accton_as7326_56x_led_auto_set,
-        .brightness_get  = accton_as7326_56x_led_auto_get,
-        .flags			 = LED_CORE_SUSPENDRESUME,
-        .max_brightness  = LED_MODE_AUTO,
-    },
-};
-
-static int accton_as7326_56x_led_suspend(struct platform_device *dev,
-        pm_message_t state)
-{
-    int i = 0;
-
-    for (i = 0; i < ARRAY_SIZE(accton_as7326_56x_leds); i++) {
-        led_classdev_suspend(&accton_as7326_56x_leds[i]);
-    }
-
-    return 0;
-}
-
-static int accton_as7326_56x_led_resume(struct platform_device *dev)
-{
-    int i = 0;
-
-    for (i = 0; i < ARRAY_SIZE(accton_as7326_56x_leds); i++) {
-        led_classdev_resume(&accton_as7326_56x_leds[i]);
-    }
-
-    return 0;
-}
-
-static int accton_as7326_56x_led_probe(struct platform_device *pdev)
-{
-    int ret, i;
-
-    for (i = 0; i < ARRAY_SIZE(accton_as7326_56x_leds); i++) {
-        ret = led_classdev_register(&pdev->dev, &accton_as7326_56x_leds[i]);
-
-        if (ret < 0)
-            break;
-    }
-
-    /* Check if all LEDs were successfully registered */
-    if (i != ARRAY_SIZE(accton_as7326_56x_leds)) {
-        int j;
-
-        /* only unregister the LEDs that were successfully registered */
-        for (j = 0; j < i; j++) {
-            led_classdev_unregister(&accton_as7326_56x_leds[i]);
-        }
-    }
-
-    return ret;
-}
-
-static int accton_as7326_56x_led_remove(struct platform_device *pdev)
-{
-    int i;
-
-    for (i = 0; i < ARRAY_SIZE(accton_as7326_56x_leds); i++) {
-        led_classdev_unregister(&accton_as7326_56x_leds[i]);
-    }
-
-    return 0;
-}
-
-static struct platform_driver accton_as7326_56x_led_driver = {
-    .probe	  = accton_as7326_56x_led_probe,
-    .remove	 = accton_as7326_56x_led_remove,
-    .suspend	= accton_as7326_56x_led_suspend,
-    .resume	 = accton_as7326_56x_led_resume,
-    .driver	 = {
-        .name   = DRVNAME,
-        .owner  = THIS_MODULE,
-    },
-};
-
-static int __init accton_as7326_56x_led_init(void)
-{
-    int ret;
-
-    ret = platform_driver_register(&accton_as7326_56x_led_driver);
-    if (ret < 0) {
-        goto exit;
-    }
-
-    ledctl = kzalloc(sizeof(struct accton_as7326_56x_led_data), GFP_KERNEL);
-    if (!ledctl) {
-        ret = -ENOMEM;
-        platform_driver_unregister(&accton_as7326_56x_led_driver);
-        goto exit;
-    }
-
-    mutex_init(&ledctl->update_lock);
-
-    ledctl->pdev = platform_device_register_simple(DRVNAME, -1, NULL, 0);
-    if (IS_ERR(ledctl->pdev)) {
-        ret = PTR_ERR(ledctl->pdev);
-        platform_driver_unregister(&accton_as7326_56x_led_driver);
-        kfree(ledctl);
-        goto exit;
-    }
-
-exit:
-    return ret;
-}
-
-static void __exit accton_as7326_56x_led_exit(void)
-{
-    platform_device_unregister(ledctl->pdev);
-    platform_driver_unregister(&accton_as7326_56x_led_driver);
-    kfree(ledctl);
-}
-
-module_init(accton_as7326_56x_led_init);
-module_exit(accton_as7326_56x_led_exit);
-
-MODULE_AUTHOR("Brandon Chuang <brandon_chuang@accton.com.tw>");
-MODULE_DESCRIPTION("accton_as7326_56x_led driver");
-MODULE_LICENSE("GPL");
diff --git a/packages/platforms/accton/x86-64/as7326-56x/modules/builds/x86-64-accton-as7326-56x-psu.c b/packages/platforms/accton/x86-64/as7326-56x/modules/builds/x86-64-accton-as7326-56x-psu.c
deleted file mode 100644
index 1c9bdc1d..00000000
--- a/packages/platforms/accton/x86-64/as7326-56x/modules/builds/x86-64-accton-as7326-56x-psu.c
+++ /dev/null
@@ -1,414 +0,0 @@
-/*
- * An hwmon driver for accton as7326_56x Power Module
- *
- * Copyright (C) 2014 Accton Technology Corporation.
- * Brandon Chuang <brandon_chuang@accton.com.tw>
- *
- * Based on ad7414.c
- * Copyright 2006 Stefan Roese <sr at denx.de>, DENX Software Engineering
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
-
-#include <linux/module.h>
-#include <linux/jiffies.h>
-#include <linux/i2c.h>
-#include <linux/hwmon.h>
-#include <linux/hwmon-sysfs.h>
-#include <linux/err.h>
-#include <linux/mutex.h>
-#include <linux/sysfs.h>
-#include <linux/slab.h>
-#include <linux/delay.h>
-#include <linux/dmi.h>
-
-#define MAX_MODEL_NAME          16
-#define MAX_SERIAL_NUMBER       19
-
-static ssize_t show_status(struct device *dev, struct device_attribute *da, char *buf);
-static ssize_t show_string(struct device *dev, struct device_attribute *da, char *buf);
-static int as7326_56x_psu_read_block(struct i2c_client *client, u8 command, u8 *data,int data_len);
-extern int as7326_56x_cpld_read(unsigned short cpld_addr, u8 reg);
-
-/* Addresses scanned
- */
-static const unsigned short normal_i2c[] = { 0x50, 0x53, I2C_CLIENT_END };
-
-enum psu_type {
-    PSU_TYPE_AC_110V,
-    PSU_TYPE_DC_48V,
-    PSU_TYPE_DC_12V,
-    PSU_TYPE_AC_ACBEL_FSF019,
-    PSU_TYPE_AC_ACBEL_FSF045
-};
-
-/* Each client has this additional data
- */
-struct as7326_56x_psu_data {
-    struct device      *hwmon_dev;
-    struct mutex        update_lock;
-    char                valid;           /* !=0 if registers are valid */
-    unsigned long       last_updated;    /* In jiffies */
-    u8  index;           /* PSU index */
-    u8  status;          /* Status(present/power_good) register read from CPLD */
-    char model_name[MAX_MODEL_NAME+1]; /* Model name, read from eeprom */
-    char serial_number[MAX_SERIAL_NUMBER];
-    enum psu_type       type;
-};
-
-static struct as7326_56x_psu_data *as7326_56x_psu_update_device(struct device *dev);
-
-enum as7326_56x_psu_sysfs_attributes {
-    PSU_PRESENT,
-    PSU_MODEL_NAME,
-    PSU_SERIAL_NUMBER, /* For ACBEL PSU only */
-    PSU_POWER_GOOD
-};
-
-/* sysfs attributes for hwmon
- */
-static SENSOR_DEVICE_ATTR(psu_present,    S_IRUGO, show_status,    NULL, PSU_PRESENT);
-static SENSOR_DEVICE_ATTR(psu_model_name, S_IRUGO, show_string, NULL, PSU_MODEL_NAME);
-static SENSOR_DEVICE_ATTR(psu_serial_number, S_IRUGO, show_string, NULL, PSU_SERIAL_NUMBER);
-static SENSOR_DEVICE_ATTR(psu_power_good, S_IRUGO, show_status,    NULL, PSU_POWER_GOOD);
-
-static struct attribute *as7326_56x_psu_attributes[] = {
-    &sensor_dev_attr_psu_present.dev_attr.attr,
-    &sensor_dev_attr_psu_model_name.dev_attr.attr,
-    &sensor_dev_attr_psu_serial_number.dev_attr.attr,
-    &sensor_dev_attr_psu_power_good.dev_attr.attr,
-    NULL
-};
-
-static ssize_t show_status(struct device *dev, struct device_attribute *da,
-                           char *buf)
-{
-	struct i2c_client *client = to_i2c_client(dev);
-	struct as7326_56x_psu_data *data = i2c_get_clientdata(client);
-    struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
-    u8 status = 0;
-
-    mutex_lock(&data->update_lock);
-
-    data = as7326_56x_psu_update_device(dev);
-	if (!data->valid) {
-        mutex_unlock(&data->update_lock);
-		return sprintf(buf, "0\n");
-	}
-
-    if (attr->index == PSU_PRESENT) {
-        status = !(data->status >> (1-data->index) & 0x1);
-    }
-    else { /* PSU_POWER_GOOD */
-        status = (data->status >> (3-data->index) & 0x1);
-    }
-
-    mutex_unlock(&data->update_lock);
-    return sprintf(buf, "%d\n", status);
-}
-
-static ssize_t show_string(struct device *dev, struct device_attribute *da,
-             char *buf)
-{
-	struct i2c_client *client = to_i2c_client(dev);
-	struct as7326_56x_psu_data *data = i2c_get_clientdata(client);
-    struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
-    char *ptr = NULL;
-
-    mutex_lock(&data->update_lock);
-
-    data = as7326_56x_psu_update_device(dev);
-    if (!data->valid) {
-        mutex_unlock(&data->update_lock);
-        return -EIO;
-    }
-
-    switch (attr->index) {
-    case PSU_MODEL_NAME:
-        ptr = data->model_name;
-        break;
-    case PSU_SERIAL_NUMBER:
-        ptr = data->serial_number;
-        break;
-    default:
-        mutex_unlock(&data->update_lock);
-        return -EINVAL;
-    }
-
-    mutex_unlock(&data->update_lock);
-    return sprintf(buf, "%s\n", ptr);
-}
-
-static const struct attribute_group as7326_56x_psu_group = {
-    .attrs = as7326_56x_psu_attributes,
-};
-
-static int as7326_56x_psu_probe(struct i2c_client *client,
-                                const struct i2c_device_id *dev_id)
-{
-    struct as7326_56x_psu_data *data;
-    int status;
-
-    if (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_I2C_BLOCK)) {
-        status = -EIO;
-        goto exit;
-    }
-
-    data = kzalloc(sizeof(struct as7326_56x_psu_data), GFP_KERNEL);
-    if (!data) {
-        status = -ENOMEM;
-        goto exit;
-    }
-
-    i2c_set_clientdata(client, data);
-    data->valid = 0;
-    data->index = dev_id->driver_data;
-    mutex_init(&data->update_lock);
-
-    dev_info(&client->dev, "chip found\n");
-
-    /* Register sysfs hooks */
-    status = sysfs_create_group(&client->dev.kobj, &as7326_56x_psu_group);
-    if (status) {
-        goto exit_free;
-    }
-
-    data->hwmon_dev = hwmon_device_register_with_info(&client->dev, "as7326_56x_psu",
-                                                      NULL, NULL, NULL);
-    if (IS_ERR(data->hwmon_dev)) {
-        status = PTR_ERR(data->hwmon_dev);
-        goto exit_remove;
-    }
-
-    dev_info(&client->dev, "%s: psu '%s'\n",
-             dev_name(data->hwmon_dev), client->name);
-
-    return 0;
-
-exit_remove:
-    sysfs_remove_group(&client->dev.kobj, &as7326_56x_psu_group);
-exit_free:
-    kfree(data);
-exit:
-
-    return status;
-}
-
-static int as7326_56x_psu_remove(struct i2c_client *client)
-{
-    struct as7326_56x_psu_data *data = i2c_get_clientdata(client);
-
-    hwmon_device_unregister(data->hwmon_dev);
-    sysfs_remove_group(&client->dev.kobj, &as7326_56x_psu_group);
-    kfree(data);
-
-    return 0;
-}
-
-enum psu_index
-{
-    as7326_56x_psu1,
-    as7326_56x_psu2
-};
-
-static const struct i2c_device_id as7326_56x_psu_id[] = {
-    { "as7326_56x_psu1", as7326_56x_psu1 },
-    { "as7326_56x_psu2", as7326_56x_psu2 },
-    {}
-};
-MODULE_DEVICE_TABLE(i2c, as7326_56x_psu_id);
-
-static struct i2c_driver as7326_56x_psu_driver = {
-    .class        = I2C_CLASS_HWMON,
-    .driver = {
-        .name     = "as7326_56x_psu",
-    },
-    .probe        = as7326_56x_psu_probe,
-    .remove       = as7326_56x_psu_remove,
-    .id_table     = as7326_56x_psu_id,
-    .address_list = normal_i2c,
-};
-
-static int as7326_56x_psu_read_block(struct i2c_client *client, u8 command, u8 *data,
-                                     int data_len)
-{
-    int result = 0;
-    int retry_count = 5;
-
-    while (retry_count) {
-        retry_count--;
-
-        result = i2c_smbus_read_i2c_block_data(client, command, data_len, data);
-
-        if (unlikely(result < 0)) {
-            msleep(10);
-            continue;
-        }
-
-        if (unlikely(result != data_len)) {
-            result = -EIO;
-            msleep(10);
-            continue;
-        }
-
-        result = 0;
-        break;
-    }
-
-    return result;
-}
-
-struct model_name_info {
-    enum psu_type type;
-    u8 offset;
-    u8 length;
-    u8 chk_length;
-    char* model_name;
-};
-
-static int acbel_psu_serial_number_get(struct device *dev)
-{
-    struct i2c_client *client = to_i2c_client(dev);
-    struct as7326_56x_psu_data *data = i2c_get_clientdata(client);
-    int status;
-
-    memset(data->serial_number, 0, sizeof(data->serial_number));
-
-    /* Read from offset 0x2e ~ 0x3d (16 bytes) */
-    status = as7326_56x_psu_read_block(client, 0x2e,data->serial_number, 16);
-    if (status < 0) {
-        data->serial_number[0] = '\0';
-        dev_dbg(&client->dev, "unable to read model name from (0x%x) offset(0x2e)\n", client->addr);
-        return status;
-    }
-
-    /* Read from offset 0x4f ~ 0x50 (2 bytes) */
-    status = as7326_56x_psu_read_block(client, 0x4f, data->serial_number + 16, 2);
-    if (status < 0) {
-        data->serial_number[0] = '\0';
-        dev_dbg(&client->dev, "unable to read model name from (0x%x) offset(0x4f)\n", client->addr);
-        return status;
-    }
-
-    return 0;
-}
-
-struct model_name_info models[] = {
-    {PSU_TYPE_AC_110V, 0x20, 8, 8,  "YM-2651Y"},
-    {PSU_TYPE_DC_48V,  0x20, 8, 8,  "YM-2651V"},
-    {PSU_TYPE_DC_12V,  0x00, 11, 11, "PSU-12V-750"},
-    {PSU_TYPE_AC_ACBEL_FSF019, 0x20, 13, 6, "FSF019"},
-    {PSU_TYPE_AC_ACBEL_FSF045, 0x20, 13, 6, "FSF045"}
-};
-
-static int as7326_56x_psu_model_name_get(struct device *dev)
-{
-    struct i2c_client *client = to_i2c_client(dev);
-    struct as7326_56x_psu_data *data = i2c_get_clientdata(client);
-    int i, status;
-
-    for (i = 0; i < ARRAY_SIZE(models); i++) {
-        memset(data->model_name, 0, sizeof(data->model_name));
-
-        status = as7326_56x_psu_read_block(client, models[i].offset,
-                                           data->model_name, models[i].length);
-        if (status < 0) {
-            data->model_name[0] = '\0';
-            dev_dbg(&client->dev, "unable to read model name from (0x%x) offset(0x%x)\n",
-                                  client->addr, models[i].offset);
-            return status;
-        }
-        else {
-            data->model_name[models[i].length] = '\0';
-        }
-
-        /* Determine if the model name is known, if not, read next index
-         */
-        if (strncmp(data->model_name, models[i].model_name, models[i].chk_length) == 0) {
-            data->type = models[i].type;
-
-            if ((models[i].type == PSU_TYPE_AC_ACBEL_FSF019) || (models[i].type == PSU_TYPE_AC_ACBEL_FSF045)) {
-                memmove(&data->model_name[7], &data->model_name[9], ARRAY_SIZE(data->model_name)-9);
-                data->model_name[6] = '-';
-                data->model_name[11] = '\0';
-            }
-
-            return 0;
-        }
-        else {
-            data->model_name[0] = '\0';
-        }
-    }
-
-    return -ENODATA;
-}
-
-static struct as7326_56x_psu_data *as7326_56x_psu_update_device(struct device *dev)
-{
-    struct i2c_client *client = to_i2c_client(dev);
-    struct as7326_56x_psu_data *data = i2c_get_clientdata(client);
-
-    if (time_after(jiffies, data->last_updated + HZ + HZ / 2)
-            || !data->valid) {
-        int status;
-        int power_good = 0;
-
-        data->valid = 0;
-        dev_dbg(&client->dev, "Starting as7326_56x update\n");
-
-        /* Read psu status */
-        status = as7326_56x_cpld_read(0x60, 0x2);
-
-        if (status < 0) {
-            dev_dbg(&client->dev, "cpld reg 0x60 err %d\n", status);
-            goto exit;
-        }
-        else {
-            data->status = status;
-        }
-
-        /* Read model name */
-        memset(data->model_name, 0, sizeof(data->model_name));
-        power_good = (data->status >> (3-data->index) & 0x1);
-
-        if (power_good) {
-            if (as7326_56x_psu_model_name_get(dev) < 0) {
-                goto exit;
-            }
-            if (data->type == PSU_TYPE_AC_ACBEL_FSF019 &&
-                acbel_psu_serial_number_get(dev) < 0) {
-                goto exit;
-            }
-
-            if (data->type == PSU_TYPE_AC_ACBEL_FSF045 &&
-                acbel_psu_serial_number_get(dev) < 0) {
-                goto exit;
-            }
-        }
-
-        data->last_updated = jiffies;
-        data->valid = 1;
-    }
-
-exit:
-    return data;
-}
-
-module_i2c_driver(as7326_56x_psu_driver);
-
-MODULE_AUTHOR("Brandon Chuang <brandon_chuang@accton.com.tw>");
-MODULE_DESCRIPTION("as7326_56x_psu driver");
-MODULE_LICENSE("GPL");
-
diff --git a/packages/platforms/accton/x86-64/as7326-56x/platform-config/r0/src/lib/x86-64-accton-as7326-56x-r0.yml b/packages/platforms/accton/x86-64/as7326-56x/platform-config/r0/src/lib/x86-64-accton-as7326-56x-r0.yml
index 31f3a13a..b9712d23 100644
--- a/packages/platforms/accton/x86-64/as7326-56x/platform-config/r0/src/lib/x86-64-accton-as7326-56x-r0.yml
+++ b/packages/platforms/accton/x86-64/as7326-56x/platform-config/r0/src/lib/x86-64-accton-as7326-56x-r0.yml
@@ -18,7 +18,7 @@ x86-64-accton-as7326-56x-r0:
       --stop=1
 
     kernel:
-      <<: *kernel-4-14
+      <<: *kernel-6-1
 
     args: >-
       nopat
diff --git a/packages/platforms/accton/x86-64/as7326-56x/platform-config/r0/src/python/x86_64_accton_as7326_56x_r0/__init__.py b/packages/platforms/accton/x86-64/as7326-56x/platform-config/r0/src/python/x86_64_accton_as7326_56x_r0/__init__.py
index e78ae812..f89f389e 100755
--- a/packages/platforms/accton/x86-64/as7326-56x/platform-config/r0/src/python/x86_64_accton_as7326_56x_r0/__init__.py
+++ b/packages/platforms/accton/x86-64/as7326-56x/platform-config/r0/src/python/x86_64_accton_as7326_56x_r0/__init__.py
@@ -111,6 +111,9 @@ class OnlPlatform_x86_64_accton_as7326_56x_r0(OnlPlatformAccton,
                 ]
             )
 
+        # initialize pca9548 idle_state
+        subprocess.call('echo -2 | tee /sys/bus/i2c/drivers/pca954x/*-00*/idle_state > /dev/null', shell=True)
+
         sfp_map =  [
         42,41,44,43,47,45,46,50,
         48,49,52,51,53,56,55,54,
